# 第5章 发送消息

**前章回顾**

到目前为止，我们已经学会了如何使用和实现自由函数（即非成员函数）。当然，我们所介绍的这些函数只是可用的非成员函数中的一小部分这些自由函数不属于任何一个特定的类，它们是C++语言的一个重要部分。我们可用通过这些函数的头信息和相关文档来了解新函数的用法。

**本章提要**

本章将重点介绍如何发消息给一个已经存在的对象，这是一种不同于只有函数调用的语法。本章还会介绍`string`、`ostream`、`istream`这几个来自标准库中的类以及两个第三方类`BankAccount`和`Grid`，和它们的成员函数。这些内容能让我们在解决问题时具有更好的开发技能，我们将会学习如何将数据成员封装到类中，并编写操作这些成员状态的成员函数。在这过程中，我们将充分认知到这样做的重要性。

我们希望在完成本章的学习之后，你将掌握：

* 如何发送消息给对象。
* 如何使用`string`和`ostream`类型的消息，并了解它们所能产生的效果。
* 如何使用`string`、`Grid`和`BankAccount`这三种类型的对象来解决相关问题。
* 了解程序员们为什么需要将软件划分成一系列类，这些类都是一组成员函数与相关成员数据的集合。

## 5.1 为真实世界建模

C++编程语言中主要有的是存储布尔类型、字符类型以及数字类型这三种原生类型，但C++中也有多种类型组成的C++类结构。例如`string`（这是个C++中已被实现的类），这个类中存储了一个字符集以及与该字符集相关的其他信息（譬如该`string`对象中的字符数，`string`对象的名称、地址等数据）。还有些类可以让程序员们存储一个大型的数据集合。但即便如此，这数百个C++类型也无法满足每个程序员的所有需求。因此在很多时候，程序员们会发现他们需要根据自己程序的需要来建模，创建属于自己的类。下面，我们以银行系统为例来讨论一下这个问题：

**银行柜台程序的书面说明**

> 请实现一个银行柜台程序，该程序要能允许银行客户通过唯一的识别方式访问银行帐号。然后，客户要能在柜台服务的帮助下完成一下多项交易活动，包括提款、存款、查询账户余额以及查看最近十笔交易记录。我们要求该系统必须要为其所有客户确保其余额的正确性。并且该系统还必须要要能应付任意数量的客户一笔以上的交易动作。

当然，我们并没有要求你立即将这个系统实现出来。但是，可以先来考虑一下该系统中会用到哪一些相关的类型。在这里我们要介绍一种简单的解决方案建模工具，用它来找出我们需要的对象类型，这个工具就是将问题的书面说明中出现的名词都写下来。然后，我们再逐个来思考最终可以用来表示系统中相关部分的候选类型。这些将被用来构建系统的类型主要来自以下三个地方：

* 问题的书面说明。
* 我们对目标问题理解。
* 编程语言所自带的类型。

这些类型应该尽可能地依据对对真实世界的建模，从中我们可以得到如下这些候选类型：

**对应解决方案模型的候选对象**

| | |
|--------------|-----------------------------|
| 银行柜台      | 交易活动                      |
| 银行客户      | 最近10笔交易记录               |
| 银行账户      | 账户余额                      |

下面我们用一张图来说明一下这个银行柜台系统还会涉及到的主要类型。你可以看到`BankTeller`是在许多其他类型对象的辅助下完成相关实现的。

![图5-1](img/5-1.png)

这份问题的书面说明告诉我们一个程序通常要由许多不同的类型组成，而不是囫囵吞枣似地实现一个系统，再为其加个用户界面那么简单。下面，我们就单以其中的`BankAccount`这个对象的类型为例来说明一下这个问题。

### 5.1.1 `BankAccount`对象

在本章接下来的篇幅中，我们会逐步将`BankAccount`这个类型实现成一个C++类，该类将会提供多个`BankAccount`对象。每个`BankAccount`对象实体都代表着一个银行账户。依据我们对银行账户的了解，首先会想到每个`BankAccount`对象应该要有个账户号码和账户余额。除此之外，`BankAccount`对象中还应该包含譬如交易记录清单、个人识别码（PIN）、母亲婚前姓氏等其它部分的值。另外还必须考虑它所要执行的银行业务，譬如创建新账户、存款、取款、查看当前账户余额等。最后还可能会有很多代表银行业务的消息（message）——例如，`generateMonthlyStatementAsPDF`。

下面，我们来对该类中集合的操作和类做个预览，先创建一个名为`BankAccount.h`的文件（`.h`这个扩展名代表了这是个头文件），然后将`BankAccount`类型定义如下，关于该类的具体实现细节，我们将会在下一章中为你呈现。

```C++
#include <string>

class BankAccount {
  public:
    BankAccount(std::string initName, double initBalance);
    // post: Construct call with two arguments:
    //       BankAccount anAcct("Hall", 100.00);

    void deposit(double depositAmount);
    // post: Credit depositAmount to the balance

    void withdraw(double withdrawalAmount);
    // post: Debit withdrawalAmount from the balance

    double getBalance() const;
    // post: Return this account's current balance

    std::string getName() const;
    // post: Return this account's name

  private:
    std::string name;
    double balance;
};
```

我们可以将这份`BankAccount`类的定义视作将来在C++中构建多个`BankAccount`对象的蓝图。如你所见，每个`BankAccount`对象都会有属于自己的数据成员：`name`和`balance`，以及五个意义相同的成员函数：`BankAccount`、`deposit`、`withdraw`、`getName`和`getBalance`。通常情况下，当我们在名为`BankAccount.h`的文件中做了这样的定义之后，就需要在另一个名为`BankAccount.cpp`的文件中对这个C++类做出具体的实现。

需要注意的是，C++社区中指称类属函数时使用的是*成员函数（member function）*这个术语`【译者注：此处原文为data member，译者认为是作者笔误，故修正于此，特做说明。】`，而在指称存储对象状态的变量时则使用的术语是*数据成员（data member）*。在其他编程语言中，人们通常使用*方法（method）*这个术语来指称前者，而不是*成员函数*。后者也一样，人们通常使用的术语是*实例变量（instance variable）*而不是*数据成员*。本教材将采用C++的术语风格。

另外我们也可以看到。`BankAccount`对象在构造时需要我们提供以下两个实参来初始化该对象的状态：

* 一个可以代表这个账户的标识符，譬如某个名称。
* 一个表示账户初始余额的浮点数。

**通用格式 5.1**： *构造对象（也可以同时设置初始值）*

> *class-name object-name*(*initial-value(s)*);

下面来看几个对象构造的示例：

```C++
BankAccount anAccount("Chris", 125.50);
string str("A string")
string str2() // default value is an empty string ""
```

如你所见，每个对象都具有：

* 名称：这是用来引用整个对象的变量。
* 状态：该对象当前所拥有的值。
* 消息：该对象可执行的操作。

每个对象都会提供一个用来访问该对象状态的变量，虽然它们拥有各自独特的状态，但能理解同一组消息。例如，在下面这个对象构造动作中，

```C++
BankAccount anotherAccount("Dakota", 60.00);
```

我们收到了以下信息：

* 用以范围该对象的名称：`anotherAccount`。
* 状态：”Dakota“这个账户名下的账户余额为60.00。
* 消息：该对象可以理解的消息包括`withdraw`、`deposit`、`getBalance`等。

也就是说，`BankAccount`类的其他实例理解的消息是相同的，但它们会有各自独立的状态。例如在下面这个`BankAccount`对象构造玩之后，

```C++
BankAccount newAccount("Kim", 1000.00);
```

`newAccount`对象的名称是“Kim”，账户余额为1000.00。

### 5.1.2 类与对象的图解

对于上述三个对象特征，我们可以用下面这张类图来汇总一下：

![图5-2](img/5-2.png)

在这张类图的最顶层部分，我们看到的是类名。接下来的部分中列出的是实例变量。最底层部分则是方法。同样的，对象也可以用下面这样一张实例图来说明，带下划线的是对象的名称，其余是它们各自的值：

![图5-3](img/5-3.png)

这三张对象的图解描述了三个不同的`BankAccount`对象当前的状态。同一个类可以构造出多个对象，这些对象拥有各自独立的状态（即各自拥有一组值）。

## 5.2 发送消息

`cin`、`cout`这样的对象也好，任何的`string`对象也罢，它们都属于有类成员函数的对象。因此它们在使用上与`cmath`中声明的自由函数是有些不同的，需要使用不同的语法。在使用成员函数时，我们甚至可以用不同的名称（即消息）调用不同类型的函数调用。有些消息会返回对象的状态，也有些消息的任务是告诉对象去做某事。

* 让对象返回其状态的消息：`anAccount.getBalance();`
* 让对象做事的消息：`anAccount.withdraw(25.00);`

我们可以通过`getName`、`getBalance`这样的操作来范围对象的状态。由于其他类成员函数的存在，程序员们也可以通过`withdraw`和`deposit`这样的函数来修改对象的状态。下面我们来看一下发送消息给对象的通用格式：

**通用格式 5.2**： *发送消息给某个对象*

> *object-name.function-name*(*argument-list*)

现在，我们来示范一下`BankAccount`对象的消息发送：

```C++
anAccount.deposit(237.42);
anAccount.withdraw(5);
anAccount.getBalance();
```

下面这些则是不正确的示范：

```C++
anAccount.deposit();        // Missing the amount to deposit
eposit();                   // missing the object-name and .
nAccount.getBalance;        // missing ()
anAccount.withdraw("10");   // wrong class of argument
anAccount;                  // missing member function name
anAccount.withdrawal(10);   // BankAccount has no function withdrawal
```

幸运的是，如果我们在编写对象名称，点号以及操作名称时出了错，编译时是会产生报错信息的。而且`与所有的函数一样，如果客户端代码没有提供正确的实参，编译器也会报错。

总之，我们现在知道了`BankAccount`类（及其产生的所有`BankAccount`对象）中有两个可用于访问其对象状态的成员函数：`getName`和`getBalance`，两个可修改状态的成员函数：`withdraw`和`deposit`。接下来，我们要来具体示范一下这些操作，下面这个程序中构造了两个`BankAccount`对象，并同步将一些消息发给了它们，这些消息将会产生一下这些活动：

* 让名为`ba1`的对象存款133.33元。
* 让名为`ba2`的对象取款250.00元。
* 显示这两个对象的名称和账户余额。

```C++
// Initialize two BankAccount objects and send some messages
#include <iostream> // for cout
using namespace std;
#include "BankAccount.h" // for class BankAccount

int main() {
    BankAccount ba1("Miller", 100.00);
    BankAccount ba2("Barber", 987.65);

    ba1.deposit(133.33);
    ba2.withdraw(250.00);

    cout << ba1.getName() << ": " << ba1.getBalance() << endl;
    cout << ba2.getName() << ": " << ba2.getBalance() << endl;

    return 0;
}
```

**程序输出**

```shell
Miller: 233.33
Barber: 737.65
```

对象中所存储的数据量是取决于其所属类的，一个对象的状态可以有许多值——这些值可能也属于不同的类。例如，`BankAccount`对象中存储了一个用来表示账户名的`string`对象和一个用来表示账户余额的数字。而`weeklyEmployee`对象则可能需要存储多个用来存储姓名、地址、社会安全号码的`string`对象，，以及用来表示工资率和工作时数的数字。`robot`对象则可能需要存储当前位置，一份地图以及其机械臂的当前状态。

**自检题**

5-1 下面每个被字母注释的行都存在着一个错误，请说明这些错误的缘由。

```C++
#include <iostream>      // For cout
#include "BankAccount.h" // For class BankAccount
using namespace std;

int main() {
    BankAccount b1("Sam");          // -a
    BankAccount b2(500.00);         // -b
    BankAccount b3("Jo", 200.00);   // -c
    b1.deposit();                   // -d
    b1.deposit;                     // -e
    b1.deposit("100.00");           // -f
    B1.deposit(100.00);             // -g
    b1.Deposit(100.00);             // -h
    withdraw(100);                  // -i
    cout << b4.getName() << endl;   // -j
    cout << b1.getName << endl;     // -k
    cout << b1.getName(100.00) << endl; // -l
    return 0;
}
```

5-2 请写出下面程序会产生的输出：

```C++
#include <iostream> // For cout
using namespace std;
#include "BankAccount.h" // For the BankAccount class

int main() {
    BankAccount b1("Chris", 0.00);
    BankAccount b2("Kim", 500.00);
    b1.deposit(222.22);
    b1.withdraw(20.00);
    b2.deposit(55.55);
    b2.withdraw(10.00);

    cout << b1.getName() << ": " << b1.getBalance() << endl;
    cout << b2.getName() << ": " << b2.getBalance() << endl;
    return 0;
}
```

## 5.3 `string`对象

和`bankAcount`类一样，`string`类型也是C++中被实现的一个类。虽然每个`string`对象中存储的都是一个字符集合，但程序员有时也会对其中的一个字符产生兴趣。除此之外，程序员有时也会需要其中的几个字符或获得当前字符串的长度（即其所存储的字符数）。甚至有时候，我们还会需要检查字符串中是否存在着某个指定的子串。例如，我们可能需要判断", "是不是字符串"Last, First"的子串，如果是的话，该子串在字符串中的首位索引是什么？C++的`string`类型提供了大量的成员函数，以帮助我们解决大部分与字符串值有关的问题，我们将来会在许多程序中用到`string`对象。

每个`string`对象都存储了一个包含0个或多个字符的集合。构造`string`对象的方法主要有以下两种。

**通用格式 5.3**： *`string`对象的两种不同构造方式*

> string *identier*(*string-literal*);<br>
> string *identier* = *string-literal*;

**实例示范**

```C++
string stringReference("A String Object");
string anotherStringReference = "Another";
```

和大多数类一样，`string`类的成员函数中也有负责修改`string`对象状态的（譬如`insert`、`replace`、`erase`）和只返回对象状态的（譬如`length`、`find`、`substr`）。另外，`string`类中还有一些允许访问其元素或个别字符的操作：`[]`、`front`和`back`。最后，还有一组作用于`string`对象本身的操作，譬如`+`、`[]`、`<<`和`>>`。

### 5.3.1 访问性方法

#### string::length()

在将`length`消息发送给`string`对象之后，它会返回该`string`对象中的当前字符数。

```C++
string stringReference("A String Object");
string anotherStringReference = "Another";
stringReference.length(); // returns 15
anotherStringReference.length(); // returns 7
```

#### string::at

`at`消息的作用是返回其`int`实参所代表的索引位置上的字符。请注意，`string`对象的索引是从0开始的，也就是说，第一个字符的索引是0，第二个字符的索引是1，要获取它就要向对象发送`at(1)`这个消息。

```C++
string str("A string object");
str.at(0); // returns 'A'
str.at(1); // returns ' '
str.at(2); // returns 's'
str.at(str.length()-1); // returns 't', the last character
```

#### string::find和string::rfind

`find`消息的作用是返回其实参字符串在目标字符串中第一次出现时的首字母索引。如果该实参字符串不存在于目标对象中，`find`就会返回一个名为`string::npos`的值（代表的是一个不存在的位置），这往往会是一个值很大的整数，用于区别其他可能返回的整数。而`rfind`则是返回其实参字符串在目标对象中最后一次出现时的首字母索引。

```C++
string str("there is the other the");
str.find("the"); // returns 0, the first "the"
cout << str.rfind("the"); // returns 19, the last "the"
cout << str.find(" is "); // returns 5
cout << str.find("not here"); // returns string::npos which
                              // may be 18446744073709551615
```

#### string::substr

`substr`消息的作用是以第一个实参指定的，在目标字符串中的索引为起点，返回第二个实参所指字符数的子字符串。

```C++
string str("Smiles a Lot");
str.substr(1, 4); // returns "mile"
str.substr(9, 1); // returns "L"
str.substr(9, 2); // returns "Lo"
str.substr(9, 55); // returns "Lot"
```

#### str::front和str::back**

`front`和`back`这两个成员函数的作用就是访问`string`对象中的首字符和尾字符。

```C++
string str("abc");
// front and back are part of C++11. With some C++ compilers,
// this code may generate compile time errors because their
// string class may does not yet have these member functions.
str.front(); // returns 'a'
str.back();  // returns 'c'
```

### 5.3.2 修改性方法

#### str::insert

`insert`消息的作用是往目标`string`对象中添加字符，它的第一个实参指定的是插入位前面的索引（即被插入字符会位于该索引位置的右边）。第二个实参则通常是一个字符串常量或其他字符串对象（即待插入的字符串）。

```C++
string quick("quick");
string all("the brown jumped dog");

all.insert(4, quick); // all.length() increased
all.insert(23, "over the lazy");
cout << all; // prints: the quick brown jumped over thelazy dog
```

#### str::replace

`replace`成员函数的作用是修改目标字符串中指定部分的内容，它的第一个实参指定的是待修改部分的起点处索引，而第二个实参则带修改部分所要跨越的字符数。

```C++
string quick("quick");
string all("the brown jumped dog");
all.replace(4, 14, quick);
cout << all; // prints: the quick dog
```

#### str::erase

`erase`消息的作用是擦除目标字符串中由其实参索引值指定部分的内容。

```C++
string all("the quick brown fox");
all.erase(4, 12);

cout << all << endl; // prints: the fox
cout << all.length(); // prints 7
```

### 5.3.3 为`string`对象本身定义的操作符

#### `+`操作符

程序员们通常需要将两个独立的字符串合并成一个字符串，这时候就可以使用`+`操作符，它可以将两个以上的字符串拼接（或者说连接）成一个字符串。

```C++
string firstName("Kim");
string lastName("Potter");

string fullName = lastName + ", " + firstName;
cout << fullName; //prints Potter, Kim
```

当然，该操作符也能将字符拼接成字符串。

```C++
fullName = '>' + fullName + '<';
cout << fullName; // prints >Potter, Kim<
```

#### `<<`和`>>`操作符

`<<`和``>>`这两个操作符对`string`类的重载使我们可以像数字一样对字符串进行输入/输出操作。

```C++
string firstName;
cout << "Enter first name: ";
cin >> firstName; // If the user enters Kim
cout << "Hello " + firstName; // output would be: Hello Kim
```

#### `[]`操作符

`[]`操作符的作用和`at`成员函数是一样的，通过这对方括号，我们也可以对目标字符串中的个别字符进行访问或修改。

```C++
string str("abcde");

str[0]; // returns 'a'
str[1]; // returns 'b'
str[4]; // returns 'e'

str[2] = 'X';
str[3] = 'O';
cout << str; // prints abXOe
```

除此之外，`string`类型还有一些用于比较的操作符，譬如`<=`和`==`等，这部分内容我们将会在之后的章节中介绍。

**自检题**

5-3 请写出下面程序会输出的结果。

```C++
#include <iostream>
#include <string>
using namespace std; // Allows string instead of std::string

int main() {
    string str("Social Network");
    cout << str.length() << endl;
    cout << str.at(0) << endl;
    cout << str.at(str.length() - 1) << endl;
    cout << str.find("Net") << endl;
    cout << str.find("net") << endl;
    cout << str.substr(7, 3) << endl;
    cout << str.substr(7, 1) << endl;
    cout << str.substr(7, 99) << endl;
    cout << str[1] << endl
    return 0;
}
```

5-4 请写出下面各`string`对象被修改之后的内容。

* a.
    ```C++
    string str1("Social");
    str1.replace(0, 1, "UnS");
    ```
* b.
    ```C++
    string str3("Social");
    str3.insert(3, "iet");
    str3.erase(6, 1);
    ```
* c.
    ```C++
    string str2("Social");
    str2.erase(3, 2);
    ```
* d.
    ```C++
    string str4("Social");
    str4[0] = 'N';
    str4[5] = 'X';
    str4\[2\] = 'T';
    ```

5-5 请编写一段代码，将某字符串中间位置的字符存储到一个名为`mid`的`char`类型的变量中，如果字符总数为偶数，则选择中间右边的字符，譬如“abcd”的中间字符为“c”。

5-6 对于下面各条消息的发送，如果你认为发送错误，就将爱标识为“error”，否则就请写出该调用表达式返回的值。

```C++
string str("Any String");
```

* a. length(str)  
* b. str.length
* c. str(length)
* d. str.find(" ")
* e. str.substr(2, 5)
* f. str.substr("tri")

## 5.4 `ostream`和`istream`的成员函数

`istream`和`ostream`是分别为我们提供输入和输出功能的两个类。

#### ostream::width

`width`成员函数的作用是修改名为`cout`的`ostream`对象的状态。

```C++
#include <iostream>
using namespace std;
int main() {
    cout << 1;
    cout.width(5);
    cout << 2;
    cout << 3;
    return 0;
}
```

**程序输出**

```shell
1     23
```

默认情况下，`cout`的状态是被设置为以最小列数继续下一项输出——也就是说，这些输出项之间是没有空格的。我们可以用`cout.width(5)`这个消息来临时改变`cout`的这种默认状态，将其到下一项输出之间的距离设置成了五列宽度。但在下一项输出之后，默认状态会重新生效，所以你会看到3紧接着出现在2的后一列中。

#### ostream::precision

如果我们想控制浮点数输出的外观，就需要用到`ostream`的成员函数`precision`。`precision`消息的作用是告诉`ostream`对象`cout`以指定的小数位来显示浮点数。和`width`不一样的是，`precision`的作用是会被保持下去的，一直`cout`收到另一个`precision`消息为止。

```C++
// Send two precision messages to the ostream object named cout
#include <iostream>
using namespace std;

int main() {
    double x = 1.23456;

    cout << x << endl;   // Default (1.23456)
    cout.precision(1);   // Modify the state of cout
    cout << x << endl;   // Show only one signi cant digit (1)
    cout.precision(4);   // Modify the state of cout
    cout << x << endl;   // Show four digits rounded (1.235)
    cout << x << endl;   // Precision of 4 still in effect

    return 0;
}
```

**程序输出**

```shell
1.23456
1
1.235
1.235
```

#### istream::good

`istream`类的成员函数`good`的作用是返回某个输入对象（通常是`cin`）的状态。一般情况下`cin.good()`返回的是1，就表示“true”，代表`cin`还能继续读取数据。反之，如果某人输入了错误的值，譬如在该输入数字的情况下输入了一个“BAD”，那么`good`消息就会返回0，代表其状态变成了“false”。

```C++
cout << cin.good(); // Returns 1 for good, 0 for bad
```

每当`cin.good()`返回的状态为false时。除非我们采取其他步骤修复该状态，否则就无法进行更多的输入了。所以，如果您输入了一个无效的数字（这种输入错误并不少见），就会出现一些意想不到的情况。

```C++
// Demonstrate what happens with bad input
#include <iostream> // For the cout and cin objects
using namespace std;

int main() {
    int x = 0.0;

    cout << "Is cin good? " << cin.good() << endl;
    cout << "Enter an int: ";
    cin >> x;
    cout << "Is cin still good? " << cin.good() << endl;

    return 0;
}
```

| 程序会话1：1代表true | 程序会话2：0代表false    |
|-------------------|-------------------------|
| Is cin good? 1   | Is cin good? 1           |
| Enter an int: 123 | Enter an int: NotAnInt  |
| Is cin still good? 1 | Is cin still good? 0 |

### 5.4.1 类成员函数的头信息

当某个函数成为某个类的成员时，其函数头信息就要用类名加`::`操作符来加以限定。在下一章中，我们将会看到`::`是成功构建C++类过程中必须要到的操作符。它还有助于读者分辨何时该用点号来发送消息。下面，我们来看一下如何将函数头信息标识为类成员函数：

**通用格式 5.4**： *类成员函数的头信息*

> *class-name* :: *function-name*(*parameters*)

所以，例如`int string::length()`就代表`length`是`string`类的一个成员，它与`sqrt`和`pow`这样的非成员函数的是不同的。下面，我们来看一些目前已经发布的类成员函数的头信息（事实上远不止这些）：

**一些类成员函数头信息的实例**

| 类型          | 成员函数                 |
|--------------|-------------------------|
| string       | int string::length() const; <br>// Return the number of characters in this string <br>int string:: nd(string subString); <br>// Return position of first substring <br>string string::substr(int pos, int n) const; <br>// Return the n characters to the right of <br>// string[pos] or up to this string's length<br>string insert (int pos, const string& str); <br>// Inserts additional characters into the string right <br>// before the character indicated by pos. |
| ostream      | int ostream::width(int nCols); <br>// Next output to this ostream object will be <br>// displayed in nCols. Returns the current value <br>// of the date member width. <br>int ostream::precision(int nDigits); <br>// Show oating-point output with nDigits of digits. <br>// Also returns the current precision. |
| istream      | int istream::good(); <br>// post: Return 1 if istream can read or 0 if corrupt |
| BankAccount  | BankAccount::BankAccount(string aName, double initBalance); <br>// post: Construct a BankAccount with two arguments <br>void BankAccount::deposit(double amount); <br>// pre: amount >= 0 <br>// post: amount is credited to this object's balance <br>void BankAccount::withdraw(double amount); <br>// pre: amount >= 0 and <= this object's balance <br>// post: amount is debited from this object's balance <br>double BankAccount::getBalance() const; <br>// post: Return this object's current balance <br>string BankAccount::getName() const; <br>// post: Return this object's name |

这种类名加`::`的形式可以帮助我们识别自己是否在调用非成员函数（即自由函数），也就是我们应该使用函数名来调用，还是用类名后面跟着点号的形式来发送消息。

| 自由函数的头信息 | 函数调用                   |
|---------------|---------------------------|
| double pow(double base, double power) <br>// post: Return base to the power power | double answer = 0.0; <br>double x = 1.023102; <br>answer = pow(x, 360.0); |
| string string::substr(int pos, int n) <br>// post: Return n characters of this <br>// string beginning at index pos | string name("Doe, Jo"); <br>int n = name.find(","); <br>string last = name.substr(0, n); |

另外，我们还需要在文档中说明这是一个需要用类名加点号来调用的类成员函数。我们将会经常看到一些没有写明形参表和返回值类型的成员函数文档（譬如`string::length`）。本教材以及其他很多在线资料和书籍都是这样处理文档的的。

**自检题**

5-7 请写出下面程序将会输出的内容，在此过程中，请确保所有的输出都位于它正确的列数上。

```C++
#include <iostream>
using namespace std;
int main() {
    cout << "123456789012345" << endl;
    cout.width(3);
    cout << 1;
    cout.width(5);
    cout << 2.3;
    cout.width(6);
    cout << "who" << endl;
    return 0;
}
```

5-8 请写出下面程序确切会输出的内容：

```C++
#include <iostream>
using namespace std;
int main() {
    cout.precision(3);
    cout << 9.876543 << endl;
    cout.precision(1);
    cout << 1.2 << endl;
    cout.precision(8);
    cout << 1.2 << endl;
    return 0;
}
```

5-9 请根据下面的输入，写出以下程序会参数的完整会话内容：

* a.  the user enters ***123***
* b.  the user enters ***XYZ***

```C++
#include <iostream>
using namespace std;
int main() {
    int anInt(0);
    cout << "Enter an integer: ";
    cin >> anInt;
    cout << "Good? " << cin.good() << endl;
    return 0;
}
```

5-10 请说出以下成员函数所需的类：

* a. istream::clear
* b. Grid::move
* c. ostream::width
* d. string::replace
* e. BankAccount::withdraw
* f. istream::good

## 5.5 另一个标准类：Grid

在这一节中，我们要来介绍另一个非标准类。我们在以后的章节中还会偶尔用到这个类，它有助于我们更深入地去思考对象的概念，这对改善解决问题的技能还是很有帮助的。

下面我们来介绍如何将`Grid`类型实现成C++类。但在正式进入本节的学习内容之前，我们需要先说明一件事：这里所设计的这个`Grid`类仅用于本教材的教学自用。我们会在后续章节中偶尔把它拿出来，利用其可视化的方式来演示一些新概念。但是，这并不意味着`Grid`对象本身在这些新概念上体现了任何优势，我们只是希望通过`Grid`对象的图形化状态让读者更容易理解用发送消息这种方式来访问或修改对象状态的过程。我们接下来要完成的一些项目，都只用向对象发送消息即可。

另外需要说明的是，`Grid`这个类是基于Rich Pattis的 *Karel the Robot: A Gentle Introduction to the Art of Programming*一文的成果以及迪斯尼世界的Epcot中心的一个游戏来完成的。该游戏会问一个问题“Could you be a programmer?”，在这个游戏里玩家需要引导一条海盗船避开一系列障碍物，最终到达宝藏所在的地方。

`Grid`对象中要存储的是一个用行列式矩阵来表示的地图和一个要被移动的对象。所以，`Grid`对象的初始化过程需要我们提供以下五个实参。

```C++
Grid Grid-name (rows, cols, mover-row, mover-col, direction);
```

前两个实参指定的是`Grid`对象中矩阵的行数和列数，接下来两个实参指定的被移动物体最初所在的行数和列数，最后一个实参指定的是被移动物体的初始方向，这里有`north`、`south`、`east`、`west`四个方向。

在下面的程序中，我们示范了`Grid`对象的初始化过程，并展示了`Grid::display`这个消息的输出。程序员们是通过这个消息来检查`Grid`对象的状态的。为了遵守C++中从0开始计数的约定俗成，这里的第一行和第一列也都会被记录成0行，0列。因此，第一行第一列所在的位置应该被记录成0，0。

```C++
// Initialize and display a Grid object
#include "Grid.h" // For the Grid class

int main() {
    // Arguments used to initialize a Grid object go like this:
    // #rows, #columns, StartRow, StartColumn, StartDirection
    Grid aGrid(8, 16, 4, 8, east); // 4 is the fth and
                                   // 8 is the ninth
    column aGrid.display();
    return 0;
}
```

**程序输出**

```shell
The Grid:
. . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . .
. . . . . . . . > . . . . . . .
. . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . .
```

可以访问`Grid`对象状态的类成员函数有以下这些：

* `int Grid::row() const`
* `int Grid::nRows() const`
* `int Grid::nColumns() const`
* `void Grid::display() const`
* `bool Grid::frontIsClear() const`

尽管这些操作我们目前未必都需要，但只要想持续解决一些与`Grid`对象相关的问题，它们迟早都会派上用场。

```C++
// Access the state of a Grid object with messages
#include <iostream> // For the cout object
using namespace std;
#include "Grid.h" // For class Grid

int main() {
    Grid aGrid(7, 14, 5, 8, east); // Column 8 is the ninth column
    cout << "Current row : " << aGrid.row() << endl;
    cout << "Current column : " << aGrid.column() << endl;
    cout << "Number of rows : " << aGrid.nRows() << endl;
    cout << "Number of columns: " << aGrid.nColumns() << endl;
    cout << "Front is clear? : " << aGrid.frontIsClear() << endl;
    return 0;
}
```

**程序输出**

```shell
Current row : 5
Current column : 8
Number of rows : 7
Number of columns: 14
Front is clear? : 1
```

下面，我们来看`Grid::move()`、`Grid::turnLeft()`和`Grid::turnRight()`这三个可以修改`Grid`对象状态的消息。

```C++
#include "Grid.h" // For the Grid class
int main() {
    Grid aGrid(7, 9, 1, 3, east);

    aGrid.move(); aGrid.move(); aGrid.turnRight(); aGrid.move();
    aGrid.move(); aGrid.turnRight(); aGrid.move(); aGrid.move();
    aGrid.turnLeft(); aGrid.move(); aGrid.move(); aGrid.display();
    return 0;
}
```

**程序输出**

```shell
The Grid:
. . . . . . . . .
. . .       . . .
. . . . .   . . .
. . .       . . .
. . .   . . . . .
. . . v . . . . .
. . . . . . . . .
```

**自检题**

5-11 请写出下面程序会输出的内容：

```C++
#include <iostream> // For cout
using namespace std;
#include "Grid.h" // For the Grid class

int main() {
    Grid aGrid(6, 6, 4, 2, east);
    aGrid.move(2);
    aGrid.turnLeft();
    aGrid.move(3);
    aGrid.turnLeft();
    aGrid.move(2);
    aGrid.display();
    cout << "row: " << aGrid.row() << endl;
    cout << "col: " << aGrid.column() << endl;
    return 0;
}
```

### 5.5.1 `Grid`对象的其他操作

`Grid`对象中还有一些其他操作，我们将会在完成本章编程项目时用到它们。这些编程项目将会为我们提供实际向对象发送消息的实践机会（即调用成员函数），通过开发算法产生出更多图形化的结果。在下面的类图中，我们列出了`Grid`类的所有成员函数，由于这些函数不需要知道其所作用对象的数据成员，所以我们在这里省略了对象的状态。

#### `Grid`的成员函数

```C++
// -- Modiers
void move();
void move(int spaces);
void turnLeft();
void turnRight();
void putDown();

void putDown(int putDownRow, int putDownCol); void toggleShowPath();
void pickUp();
void block(int blockRow, int blockCol);

// -- Accessors
bool frontIsClear() const;
bool rightIsClear() const;
int row() const;
int column() const;
int nRows() const;
int nColumns() const;
void display() const;
```

尽管这幅类图为我们提供了该类合法消息的概要，但它并没有说明发送这些消息时所需实参的数量和类型。因此，我们接下来要再提供一份这些成员函数头信息的子集（其中包含了在本章“编程项目”部分中会用到的那些成员函数），以及它们的前置条件和后置条件。

#### `Grid`类成员函数的子集

这些信息将有助于我们理解每个函数的功能。前置条件告诉我们在发送消息之前必须要确定的事，而后置条件则会告诉我们在前置条件被满足之后该函数会做的事。

```C++
Grid::Grid(int Rows, int Cols,
           int startRow, int startCol,
           int direction)
// post: Construct a 10-by-10 Grid object with 5 arguments
//       Grid aGrid(10, 10, 0, 0, east);

void Grid::move()
// pre: The mover has no obstructions in the next space
// post: The mover is 1 space forward

void Grid::move(int spaces)
// pre: The mover has no obstructions in the next spaces
// post: The mover is spaces forward

void Grid::putDown(int putDownRow, int putDownCol)
// pre: The intersection (putDownRow, putDownCol) has nothing at
//      it except, perhaps, the mover
// post: There is one thing at the intersection

void Grid::pickUp()
// pre: There is something to pick up at the mover's location
// post: There is nothing to pick up from the current intersection

void Grid::turnLeft() // post: The mover is facing 90 degrees counterclockwise

void Grid::block(int blockRow, int blockCol)
// pre: There is nothing at the intersection (blockRow, blockCol)
// post: The intersection can no longer be visited

void Grid::display() const
// post: The current state of the Grid is displayed on the screen
```

例如，假设我们要写这样一个程序，它要能让图中的小人避开三个指定交汇点（用`#`表示），然后让他吃到两块饼干之后返回出发位置。该怎么做呢？首先，我们要发送一些`Grid::putDown`消息来放置“饼干”（你可以根据自己喜欢来设置它，譬如这里使用了O字母）。接下来，我们就可以根据`Grid`类的成员函数（譬如`Grid::move`）来发送相应的消息来移动小人，帮助它吃到饼干了。如果小人向南走，我们就会看到它变成了`v`，向北则是`^`。同样的，如果小人向东移动，他就会变成`>`，向西则就是`<`。另外，为了让小人完成“吃”饼干这个动作，我们还需要向其发送`Grid::pickUp`消息。下面我们就具体来看一下这个程序：

```C++
// This program sets two cookies on the table and instructs a kid
// on how to locate them, "eat" them, and return home
#include "Grid.h" // For the Grid class

int main() {
    Grid kid(8, 12, 0, 0, south);
    kid.putDown(4, 0);
    kid.putDown(4, 3);
    kid.block(3, 2); // Can't move through a block #
    kid.block(4, 2);
    kid.block(5, 2);
    // Show the state of kid
    kid.display();

    // "Eat" two cookies
    kid.move(4);
    kid.pickUp();
    kid.move(2);
    kid.turnLeft();
    kid.move(3);
    kid.turnLeft();
    kid.move(2);
    kid.pickUp();

    // Get the kid back home
    kid.move(4);
    kid.turnLeft();
    kid.move(3);

    // Show the ending state
    kid.display();
    return 0;
}
```

**程序输出**

```shell
> The Grid
v . . . . . . . . . . .
. . . . . . . . . . . .
. . . . . . . . . . . .
. . # . . . . . . . . .
O . # O . . . . . . . .
. . # . . . . . . . . .
. . . . . . . . . . . .
. . . . . . . . . . . .

The Grid
<       . . . . . . . .
  . .   . . . . . . . .
  . .   . . . . . . . .
  . #   . . . . . . . .
  . #   . . . . . . . .
  . #   . . . . . . . .
        . . . . . . . .
. . . . . . . . . . . .
```

### 5.5.2 不满足前置条件的情况

我们也可能会向`Grid`对象发送许多“非法”的消息。例如，我们在向其发送`move`消息时会让小人撞上障碍物（`#`）或者直接将其移出`Grid`的地图边界，以及所有不正确的消息（譬如实际要移动的是四行而不是三行等）。

**自检题**

5-12 如果是你在为`Grid`对象设计操作，你会希望防止哪些情况发生？

那么，当`Grid`对象收到一条无意义消息时，它应该怎么做呢？坦率地说，事情会有点尴尬。该对象通常做不了什么反应。在这种情况下，对象的状态可能会保持不变，或者对象会一步移到其网格的末端或直接穿过障碍物——这看起来似乎变成了一个超人对象。除此之外，我们对这个问题还有个比较滑头的答案，那就是对象的行为是“未定义”的。

这种尴尬情景要利用前置条件的概念来避免。函数的“前置条件”是指该函数只能在某个假设成立时才能执行函数调用或发送消息的动作。例如，`void move(int spaces)`这个操作的前置条件是小人的移动路径上不能撞上障碍物或网格边界。同样地，`Grid::pickUp()`的假设则是小人所在的位置必须要有东西可以被拿起来。

```C++
void Grid::move(int spaces)
// pre: The mover has no obstructions in the next spaces
// post: The mover is spaces forward

void Grid::pickUp()
// pre: There is something to pick up at the mover's location
// post: There is nothing to pick up from the current intersection
```

那么，当我们违反其中某个前置条件会怎样呢？如果你去研究一下与`Grid`相关的其他编程项目，就会找到答案。

### 5.5.3 即使函数没有任何实参也必须用()来调用

其实目前我们已经见过几个不需要实参的消息了。事实上，只要一个函数没有定义形参，它在被调用时就不需要提供实参。下面我们来看两个示例：

```C++
cout << aString.length() << endl;
cout << aGrid.row() << endl;
```

在做本章“编程项目”中的任何项目之前，读者还应该要注意，即使我们没有值需要通过实参传递给`string::length`或`Grid::row`，在发送消息时也必须使用括号。像下面这样的话，代码是不会照你的预期来执行的：

```C++
cout << aString.length << endl; // ERROR: Missing () after length
cout << aGrid.row << endl;      // ERROR: Missing () after row
```

这里的括号代表的是函数调用操作符。没有`(`和`)`，就没有函数调用操作——即使函数需要的实参个数为0。

## 5.6 类和函数为何而存在？

*抽象（Abstraction）*是一个提炼并凸显复杂系统中相关特性的概念，这个概念的其中一个面向就是让我们从编程语言的层次来理解计算机，而不必再完全了解其更低层次的细节。所以，抽象化是我们对抗复杂性的一个武器。

正如大家所知，我们在C++中会使用`sqrt`、`pow`、`Grid::move`以及任何由第三方程序员开发，并不了解其实现细节的函数。另外，抽象化也可以让程序员们可以轻松使用`int`、`double`、`string`、`BankAccount`和`Grid`这些对象，同样也不必知道它们的实现细节，譬如`int`类型的数值特征（包括整数的取值范围）以及该类型支持的操作（包括加法、减法、赋值、输入与输出等），或者这些操作在硬件和软件中的具体实现。总而言之，抽象化可以让编程变得更友好，让我们生活得更轻松，而且有助于我们更理性地处理问题。程序员经常将被抽象化的代码说成是一个“黑盒子（black box）”。也就是说，但一个函数的实现设计对外界不可见的话，程序员就将其称之为“黑盒子”。这就是所谓的抽象化。

即便C++本身自带了大量函数和类的抽象体集合，但额外的函数和类显然还是会被需要的，因为新的抽象体是需要根据现有的对象、操作和算法来构建的。当我们在建立函数和类这些抽象体时，应该要为抽象体的构建设置一个目标，一边它们更容易被使用并能执行定义明确的操作。这样一来，即便我们在很长时间之后忘记了这些抽象体的具体细节，也能继续使用它们，因为这只需要我们知道它们会“做什么”，不必记得它们具体是怎么做的。

当然，我们也可以将所有代码都直接编码在`main`函数里，不把相关的代码分组封装成函数，然后用函数调用来替代这些语句。但其结果就如下表所示的那样，这种直接编码的方式带来的代码行数是非常巨大的。

**一条消息所代表的操作**

| 操作 | 面向对象的方式 | 直接编码的方式  |
|-----|--------------|---------------|
| 构造`Grid`对象 | `Grid g(15,15,9,4,east);` | 需要35行代码 |
| 朝当前方向移动 | `g.move(2);` | 需要112行代码 |
| 输出`Grid`的状态 | `g.display();` | 需要6行代码 |
| 改变移动方向 | `g.turnLeft();` | 需要10行代码 |

在上述表中，中间一列所显示的那四条消息都是对其右边一列中那163行非函数化代码的抽象化。大家可以想像一下，如果我们现在发送六条消息，移动三次，转向三次，情况会如何呢？这六条消息的等效非函数化代码有足足366行！

但如果将多行细节性的代码放入函数，程序员就可以用发送消息或函数调用的方式来执行相关操作了。而且，相同的消息还可以进行反复地发送多次。因此对于那些需要在程序中多次使用的代码，我们最好把它们写成自由函数（即非成员函数），或对象可用的成员函数。函数调用和消息发送还有助于隐藏许多实现细节，程序员通常是不需要看到或了解所有实现细节的，而且将代码封装在函数中也可用避免代码重复，这往往是程序员会产生编码错误的一个信号。这里常提到的*抽象化*、*封装*、*黑盒*这些术语的核心含义都是在指隐藏信息。

**自检题**

5-13 请遵照上面的表格写出，如果我们用面向对象的方式来对`Grid`对象的状态进行初始化，需要多少行代码？

5-14 请遵照上面的表格写出，如果我们用直接编码的方式（即表格的最右一列）来对`Grid`对象的状态进行初始化，需要多少行代码？

5-15 请用纸和笔来编写这样一个程序：构建一个`Grid`对象，并依次向北、东、南、西向四个方向都移动一格。

通过将底层细节分割到函数中，同样的实现我们就只需要编写一次就可以了。函数的另一优势就是同一个操作可以通过一行消息反复多次地使用。相较于一个巨大的`int main() { }`，显然是由一组非成员函数（即自由函数）的调用和类成员函数所构成的消息所组成的程序更容易被管理。下面，我们来总结一下程序员在C++中使用现有的函数和对象能更好地管理软件开发复杂性的一些原因

* 这样做可以重用现有的代码，不用一切从头开始写。
* 这样做可以将精力集中在手上较大的问题上。
* 函数只需编写一次，就可以进行彻底的测试，有助于减少错误。

在早期的编程中，程序经常会被写成一个巨大的主程序。但随着程序的规模越来越大，*结构化变成（structured programming)*逐渐成为了流行趋势。结构化编程的主要特征之一就是它主张将程序划分为一系列函数，以便更好地管理代码。程序员们也发现这种方式能帮助人们更好地理解他们的程序，而且在独立的函数中维护相关的细节，也要比面对一整个主程序容易多了。毕竟，在一个拥有200个函数的程序中修复一个20行的代码，要比修复一个2000行的程序要容易得多。除此之外，我们会将程序分割成函数的理由还包括：

* 将实现细节放入到函数或类中，能使代码跟容易被理解。
* 这样做可以使我们在同一个程序中多次执行相同的操作。
* 这些函数和类也可以在别的应用中被重用。

但在我们使用自由函数时，数据会在非成员函数之间来回传递。当数据在整个大型程序中随处可见时，它被意外修改的机率就会大幅增加。

如今，随着软件越来越复杂，用对象技术来按操作的数据对函数进行分组封装的想法也被提了出来，以便开发人员不必在不同组的非成员函数之间乱抛数据，后者显然会为许多意外攻击大开方便之门。正如我们将会在下一章中看到的，在面向对象的编程中，数据和函数被封装在了一起——这种设计既优雅又安全。

**程序被组成模块的历史发展过程**

![图5-4](img/5-4.png)

```
图中翻译：{
    the early day：早期
    structured：结构化
    object-oriented：面向对象
}
```

**自检题**

5-16 对于你而言，使用函数最重要的原因是什么？

5-17 请用一个实例说明一下抽象化在日常工作中是如何帮助我们的。

## 本章小结

* `string`类由一组数量庞大的，操作`string`对象中所有或部分字符的操作组成，其中包括了`substr`、`find`、`at`、`replace`以及`length`等函数。
* 某些消息需要在其函数名之前加上对象名和点号（`.`），并配上实参才能调用。也就是说，它们的调用形式应该是`aString.substr(2, 5)`，而不是`substr(aString, 2, 5)`。
* 我们可以用`cout.width(10)`的列宽输出10列右对齐的数字（或是用`cout.width(9)`的列宽输出9列等）。在这里，新列的起点位于前一个输出值之后，而不是其自身的左边距。
* 类成员函数通常要用类名加域操作符`::`的形式来表明这是一个对象类的消息，所以我们看到的是`ostream::width`而不是直接的`width`。
* 类成员函数头信息所能给出的用法信息和非成员函数（`sqrt`、`pow`、`fmod`）是一样的，即给定的返回值类型。函数名以及调用时必须要使用的实参类型等。
* 类成员函数在外部被引用时必须要加上其所属的类名，譬如`void Grid::move()`。
* 本教材所使用的大部分类都是C++标准库的一部分。额外的`BankAccount` 和`Grid`这两个类也可以在本教材的官方网站上获得。
* 类图的作用就是通过类（对象）的任意实例来理解其消息的名称。当然，想要正确地发送信息，程序员们必须要知道更多的信息（譬如其实参所属的类和它们的数量）。这就是我们要为说明前置条件和后置条件的原因。
* 在20世纪60年代，程序通常是以语句集的方式来编写的。而到了20世纪70年代，程序就逐渐成了自由函数的集合，从20世纪90年代开始，越来越多的程序变成了一组可交互对象的集合，这里的每个对象都是一个包含某组成员函数的类的实例。上次每一次的改进都让我妈可以构建出更复杂的软件。
* 抽象化意味着程序员可以在不知道实现细节的情况下调用函数或发送消息。确实在很多情况下，程序员只需要知道函数名、返回值类型、实参所属的类和它们的数量就可以了。

## 练习题

1. 请写出你认为下列程序会产生的输出内容：
    ```C++
    #include <iostream>
    using namespace std;
    #include "BankAccount.h" // For class Grid

    int main() {
        BankAccount b1("One", 100.00);
        BankAccount b2("Two", 200.00);
        b1.deposit(50.00);
        b2.deposit(30.00);
        b1.withdraw(20.00);
        cout << b1.getBalance() << endl;
        cout << b2.getBalance() << endl;
        return 0;
    }
    ```

2. 在下面程序被执行时，如果用户的输入依次是：`MyName`、`100`、`22.22`、`44.44`，请写出其完整的会话过程。
    ```C++
    #include <iostream> // For cout and endl
    using namespace std;
    #include "BankAccount.h" // For the BankAccount class
    int main() {
        string name;
        double start, amount;
                                      // Input:
        cout << "name: ";             // MyName
        cin >> name;
        cout << "initial balance: ";  // 100
        cin >> start;

        // Construct a BankAccount
        BankAccount one(name, start);

        cout << "deposit? ";          // 22.22
        cin >> amount;
        one.deposit(amount);

        cout << "withdraw? ";         // 44.44
        cin >> amount;
        one.withdraw(amount);

        cout << "balance for " << one.getName() << " is "
                               << one.getBalance() << endl;
        return 0;
    }
    ```

3. 请写出你认为下列程序会产生的输出内容：
    ```C++
    #include <iostream> // For the object cout
    using namespace std;
    #include "Grid.h" // For the Grid class
    int main() {
        Grid aGrid(6, 6, 1, 1, south);
        aGrid.putDown(2, 3); // Place thing at a specific intersection
        aGrid.block(0, 0);
        aGrid.block(5, 5);
        aGrid.move(2);
        aGrid.turnLeft();
        aGrid.putDown(); // Place thing where the mover is
        aGrid.move(3);   // located, which appears as &
        aGrid.turnLeft();
        aGrid.putDown(); // Place object where the mover is located
        aGrid.move(1);
        aGrid.turnLeft();
        aGrid.move(1);
        aGrid.display();
        cout << "Mover: row#" << aGrid.row() << " col#" << aGrid.column()
             << endl;
        return 0;
    }
    ```

4. 请问在下面程序中，`position`的值是什么？
    ```C++
    string s("012345678");
    // Initialize position to the rst occurrence of "3" in s
    int position = s.find("3");
    ```

5. 请问在下面程序中，`s2`的值是什么？
    ```C++
    string s1("012345678");
    string s2(s1.substr(3, 2));
    // assert: s2 is a substring of s1
    ```

6. 请问在下面程序中，`lengthOfString`的值是什么？
    ```C++
    string s3("012345678");
    int lengthOfString = s3.length();
    // assert: lengthOfString stores the number of characters in s3
    ```

7. 请在`double`、`int`、`ostream`、`istream`、`string`、`BankAccount`、`Grid`中选择最适合用来表述下面各项问题的类：
    * a.  表示某一学科的学生人数。
    * b.  表示某位学生的平均成绩。
    * c.  表示某位学生的名字。
    * d.  表示某测试中的问题数量。
    * e.  表示某个人的储蓄账户。
    * f.  模拟一个非常有限版的吃豆人游戏。
    * g.  读取用户输入。
    * h.  显示输出内容。

8. 请列举两个程序员会选择使用或实现函数的理由。

9. 程序员必须理解`Grid::move`的具体实现才能使用它吗？

10. 请根据以下成员函数的头信息回答下列问题：

    ```C++
    void Grid::block(int blockRow, int blockCol)
    // pre: The intersection at (blockRow, blockCol) has nothing
    //      at all on it, not even the mover
    // post: The intersection at (blockRow, blockCol) is blocked. The
    //       mover cannot move into this intersection.
    ```

    * a.  该成员函数的名称是什么？
    * b.  该成员函数的返回值类型是什么？
    * c.  该成员函数所需的类是什么？
    * d.  假设现在已经有了一个名为`aGrid`的`Grid`对象，请问如何向其发送一个有效消息。

11. 请编写一个完整的C++程序，该程序会先初始化一个`BankAccount`对象，其账户余额为`$500.00`，账户名即你自己的名字。接着用户要存款`$125`，取款`$20.00`。然后请显示之后的账户名和账户余额。其大体输出应该如下：

```shell
name: Your Name
balance: 605
```

## 编程小技巧

1. 我们待会需要用到作者提供的些文件来完成一些编程项目，你需要用`""`而不是`< >`来包含这些文件（譬如"Grid.h"和"BankAccount.h"）。这两个文件应该与我们`main`函数所在的`.cpp`文件处于相同的目录（文件夹）下。你可以从本教材的官方网站上下载到相关的文件。

2. 在使用`#include`引入文件时应注意区分标准库文件和非标准库文件（后者也叫用户定义文件）。引入标准库文件（包括类和对象）的`#include`指令使用的`< >`，而非标准库的则是`" "`，下面来看一些示例：
    ```C++
    #include <string> // For the standard string class
    #include <iostream> // For cout and cin
    using namespace std; // Required to avoid writing std::cout
    #include "BankAccount.h" // For class BankAccount
    #include "Grid.h" // For class Grid
    ```
3. 即使没有实参，调用消息是也必须要以`()`结尾，不要忘记不需要实参的消息后面也要加一对括号。
    ```C++
    cout << myAcct.balance;    // Error: This references a memory location
    cout << myAcct.balance();  // Good

4. C++是从0，而不是从1开始计数的，所以`string`对象中首字符的索引是0，而不是1。
    ```C++
    cout << aString[0]; // Return the first character
    cout << aString\[1\]; // Return the second character
    ```

5. 不要引用`aString[aString.length()]`这个字符，因为这是在试图引用一个不在0到`aString.length()-1`区间内的单值。通常情况下，我们是不会引用一个`string`对象中不存在的字符的。
    ```C++
    string aString;
    aString = "This string has 29 characters";

    cout << aString[-1]; // ERROR: -1 is out of range, only use 0..28
    cout << aString[aString.length()]; // ERROR: 29 is also out of range
    ```
6. 只有一个实参的对象有两种不同的构造方法（当然，C++11又定义了一种，但这种方式直到最近才被使用，这里就不与讨论了。），一种使用的是括号，另一种使用的是赋值操作符、
    ```C++
    string state1 = "Arizona";
    string state2("Minnesota");

    int n2 = 0;
    int n1(0);

    double x2 = 0.0;
    double x1(0.0);
    ```
但是，如果对象有两个以上的初始值的话，那就只能使用括号了，譬如：

    ```C++
    BankAccount anAcct("Skyler", 23.41);
    Grid aGrid(12, 12, 0, 0, east);
    ```

7.  `::`操作符的作用是标明一个函数所属的类，因此该操作符叫做“域解析操作符”。类名之后加上`::`操作符可以将一个函数标注为成员函数，这样一来，该类的所有实例都将其理解成一个消息。因此，`string::length`这个标注将会让所有的`string`对象将`length`理解成一个消息。然而，类名加`::`这种形式是不能用于调用消息的。
    ```C++
    BankAccount anAcct("Milan", 345.67);

    // Need 'object-name.functionName' not 'class-name::functionName'
    cout << BankAccount::balance(); // Invalid
    cout << anAcct.balance(); // A valid message
    ```

## 编程项目

### 5A A LITTLE CRYPTOGRAPHY

Write a C++ program that hides a message in five words. Use one of the characters in the fi ve input strings to spell out one new word. Make up at least one other message besides these two that requires running the same program twice:

```shell
Enter ve words: ***cheap energy can cause problems***
Enter ve integers: ***4 2 1 0 5***
Secret message: peace

Enter ve words: ***programming is very complex work***
Enter ve integers: ***3 0 0 5 2***
Secret message: giver
```

### 5B LETTER I

Write the code that would go in a main function that constructs a 13-by-7 Grid object and then instructs the mover to “draw” the letter I exactly as shown (the mover could be left anywhere next to the I).

```shell
. . . . . . .
. . . . . . .
. .       . .
. . .   . . .
. . .   . . .
. . .   . . .
. . .   . . .
. . .   . . .
. . .   . . .
. . .   . . .
. .       > .
. . . . . . .
. . . . . . .
```

### 5C HURDLES

Write a function void jumpOneHurdle(Grid & g) that instructs the mover to jump one “hurdle” (the block \#). Th e main function must make five calls to this function and display the current state after each function call to jumpOneHurdle.

```C++
g.display(); // Show initial state, just after construction
jumpOneHurdle(g); g.display();
jumpOneHurdle(g); g.display();
jumpOneHurdle(g); g.display();
jumpOneHurdle(g); g.display();
jumpOneHurdle(g); g.display();
```

The first display message should show this state of the Grid object:

```shell
The Grid:
. . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . .
> . . # . . . # . . . # . . . # . . . # . . .
. . . . . . . . . . . . . . . . . . . . . . .
```

The sixth display message should show the mover has jumped five hurdles:

```shell
The Grid:
. . . . . . . . . . . . . . . . . . . . . . .
. .       .       .       .       .       . .
      #       #       #       #       # > . .
. . . . . . . . . . . . . . . . . . . . . . .
```

### 5D STAIR CLIMB

Write a function void climbStair(Grid & g) that instructs the mover to climb one step and call it enough times to climb to the top of the stairs. You will need six block messages to simulate the stairs below.

*Before*        *After*

![图5-5](img/5-5.png)

### 5E TEN String PROCESSING FUNCTIONS

Write one C++ program that uses this test driver as a main function to generate the output shown by calling ten new free functions, which are specifi ed below.

```C++
// Test drive 10 String processing functions
int main() {
    cout << "      matterAntiMatter(\"LOL\"): " << matterAntiMatter("LOL")     << endl;
    cout << "         removeEnds(\"MarkeR\"): " << removeEnds("Marker")        << endl;
    cout << "               tripleUp(\"on\"): " << tripleUp("on")              << endl;
    cout << "   splitString(\"IU\", \"owe\"): " << splitString("IU", "owe")    << endl;
    cout << "     reverse7Chars(\"1234567\"): " << reverse7Chars("1234567")    << endl;
    cout << "         halfAndHalf(\"ABcde\"): " << halfAndHalf("ABcde")        << endl;
    cout << "   nameRearranged(\"Li,Kim R\"): " << nameRearranged("Li, Kim R") << endl;
    cout << "        middleThree(\"123456\"): " << middleThree("123456")       << endl;

    // Use reference parameters instead of returning a string
    string str1("abacada");
    remove3(str1, "a");
    cout << " remove3(\"abacada\", \"a\"): " << str1 << endl;

    string str2("ornoon");
    replace(str2, 'o', 'X');
    cout << "replace(\\"ornoon\\", 'o', 'X'): " << str2 << endl;

    return 0;
}
```

**Expected Output**

```shell
    matterAntiMatter("LOL"): Anti-LOL
       removeEnds("MarkeR"): arke
             tripleUp("on"): 1)on 2)on 3)on
   splitString("IU", "owe"): IoweU
   reverse7Chars("1234567"): 7654321
       halfAndHalf("ABcde"): cdeAB
nameRearranged("Li, Kim R"): Kim R. Li
      middleThree("123456"): 345
    remove3("abacada", "a"): bcda
replace("ornoon", 'o', 'X'): XrnXXn
```

1. string antiMatter(string matter)

Everyone knows that interplanetary space travel is fueled by letting matter and antimatter mix. With this in mind, write a function antiMatter that takes a string with the name of some thing or idea. Return a string with “Anti-” prepended to it. Don’t forget the hyphen.

```shell
matterAntiMatter("Shoes") returns "Anti-shoes"
matterAntiMatter("noisy trucks") returns ""Anti-noisy trucks"
matterAntiMatter("LOL") returns "Anti-LOL"
```

2. string removeEnds(string str)

Complete method removeEnds to return a substring of the supplied string that does not have the characters at either end. Precondition: str always has at least two characters.

```shell
removeEnds ("MarkeR") returns "arke"
removeEnds ("mom") returns "o"
removeEnds ("to") returns ""
```

3. string tripleUp(string str)

Complete method tripleUp to return a string that has the argument repeated three times with 1), 2), and 3) as shown. Precondition: str.length() 1 tripleUp("top") returns "1)top 2)top 3)top"

4. string splitString(string str, string mid)

This function takes in a string of length 2 or greater, and returns a string with a space added into the middle of the string. If the string’s length is an odd number, the second half of the string will be the longer half.

```shell
splitString("IU", "owe") returns "IoweU"
splitString("ab", "_ _") returns "a_ _b"
```

5.  string halfAndHalf(string str)

Complete method halfAndHalf to return a new string that has the first half of the argument at the end and the last half of the argument at the beginning. If there are an odd number of letters, consider thelast half to have one more character than the first half before the split. Precondition: str.length() 2.

```shell
halfAndHalf("1234abcd") returns "abcd1234"
halfAndHalf("ABcde") returns "cdeAB"
halfAndHalf("Hello") returns "lloHe"
```

6. string nameRearranged(string name)

Implement nameRearranged that takes a name in the form lastName, ", " firstName, and an initial and returns a string in the form of firstName, initial, ". " and lastName.

```shell
nameRearranged("Jones, Kim R") returns "Kim R. Jones"
```

7. string middleThree(string str)

Implement middleThree so it returns the middle three characters of any string that has three or more characters. If the length of name is even, favor the right. Precondition: str.length() 3.

```shell
middleThree("Rob") returns "Rob"
middleThree("Roby") returns "oby"
middleThree("Robie") returns "obi"
middleThree("123456") returns "345"
```

8. string reverse7Chars(string str)

Implement reverse7Chars so it returns a string that is the reverse of the argument. Precondition: Th e argument str is seven characters long.

```shell
reverse7Chars("1234567") returns "7654321"
reverse7Chars("morning") returns "gninrom"
```

9. void remove3(string & str, string sub)

Implement remove3 so it modifies the string argument str such that the first three occurrences of sub are removed. Precondition: The argument sub exists at least three times in str.

```C++
string str("there is the other the");
removeThree(str, "he"); // str changes to " tre is t otr the"

string str2("to be or to be or to be");
removeThree(str2, "to "); // str2 changes to " be or be or be"
```

10. void replace(string & str, char oldC, char newC)

Implement replace to modify the string argument str so that the first three occurrences of oldC are changed to newC. Precondition: The argument oldC exists at least three times in str.

```C++
string str3("ornoono");
replace(str3, 'o', 'X'); // str3 changes to Xr nXXno
```