# 第5章 发送消息

**前章回顾**

到目前为止，我们已经学会了如何使用和实现自由函数（即非成员函数）。当然，我们所介绍的这些函数只是可用的非成员函数中的一小部分这些自由函数不属于任何一个特定的类，它们是C++语言的一个重要部分。我们可用通过这些函数的头信息和相关文档来了解新函数的用法。

**本章提要**

本章将重点介绍如何发消息给一个已经存在的对象，这是一种不同于只有函数调用的语法。本章还会介绍`string`、`ostream`、`istream`这几个来自标准库中的类以及两个第三方类`BankAccount`和`Grid`，和它们的成员函数。这些内容能让我们在解决问题时具有更好的开发技能，我们将会学习如何将数据成员封装到类中，并编写操作这些成员状态的成员函数。在这过程中，我们将充分认知到这样做的重要性。

我们希望在完成本章的学习之后，你将掌握：

* 如何发送消息给对象。
* 如何使用`string`和`ostream`类型的消息，并了解它们所能产生的效果。
* 如何使用`string`、`Grid`和`BankAccount`这三种类型的对象来解决相关问题。
* 了解程序员们为什么需要将软件划分成一系列类，这些类都是一组成员函数与相关成员数据的集合。

## 5.1 为真实世界建模

C++编程语言中主要有的是存储布尔类型、字符类型以及数字类型这三种原生类型，但C++中也有多种类型组成的C++类结构。例如`string`（这是个C++中已被实现的类），这个类中存储了一个字符集以及与该字符集相关的其他信息（譬如该`string`对象中的字符数，`string`对象的名称、地址等数据）。还有些类可以让程序员们存储一个大型的数据集合。但即便如此，这数百个C++类型也无法满足每个程序员的所有需求。因此在很多时候，程序员们会发现他们需要根据自己程序的需要来建模，创建属于自己的类。下面，我们以银行系统为例来讨论一下这个问题：

**银行柜台程序的书面说明**

> 请实现一个银行柜台程序，该程序要能允许银行客户通过唯一的识别方式访问银行帐号。然后，客户要能在柜台服务的帮助下完成一下多项交易活动，包括提款、存款、查询账户余额以及查看最近十笔交易记录。我们要求该系统必须要为其所有客户确保其余额的正确性。并且该系统还必须要要能应付任意数量的客户一笔以上的交易动作。

当然，我们并没有要求你立即将这个系统实现出来。但是，可以先来考虑一下该系统中会用到哪一些相关的类型。在这里我们要介绍一种简单的解决方案建模工具，用它来找出我们需要的对象类型，这个工具就是将问题的书面说明中出现的名词都写下来。然后，我们再逐个来思考最终可以用来表示系统中相关部分的候选类型。这些将被用来构建系统的类型主要来自以下三个地方：

* 问题的书面说明。
* 我们对目标问题理解。
* 编程语言所自带的类型。

这些类型应该尽可能地依据对对真实世界的建模，从中我们可以得到如下这些候选类型：

**对应解决方案模型的候选对象**

| | |
|--------------|-----------------------------|
| 银行柜台      | 交易活动                      |
| 银行客户      | 最近10笔交易记录               |
| 银行账户      | 账户余额                      |

下面我们用一张图来说明一下这个银行柜台系统还会涉及到的主要类型。你可以看到`BankTeller`是在许多其他类型对象的辅助下完成相关实现的。

![图5-1](img/5-1.png)

这份问题的书面说明告诉我们一个程序通常要由许多不同的类型组成，而不是囫囵吞枣似地实现一个系统，再为其加个用户界面那么简单。下面，我们就单以其中的`BankAccount`这个对象的类型为例来说明一下这个问题。

### 5.1.1 `BankAccount`对象

在本章接下来的篇幅中，我们会逐步将`BankAccount`这个类型实现成一个C++类，该类将会提供多个`BankAccount`对象。每个`BankAccount`对象实体都代表着一个银行账户。依据我们对银行账户的了解，首先会想到每个`BankAccount`对象应该要有个账户号码和账户余额。除此之外，`BankAccount`对象中还应该包含譬如交易记录清单、个人识别码（PIN）、母亲婚前姓氏等其它部分的值。另外还必须考虑它所要执行的银行业务，譬如创建新账户、存款、取款、查看当前账户余额等。最后还可能会有很多代表银行业务的消息（message）——例如，`generateMonthlyStatementAsPDF`。

下面，我们来对该类中集合的操作和类做个预览，先创建一个名为`BankAccount.h`的文件（`.h`这个扩展名代表了这是个头文件），然后将`BankAccount`类型定义如下，关于该类的具体实现细节，我们将会在下一章中为你呈现。

```C++
#include <string>

class BankAccount {
  public:
    BankAccount(std::string initName, double initBalance);
    // post: Construct call with two arguments:
    //       BankAccount anAcct("Hall", 100.00);

    void deposit(double depositAmount);
    // post: Credit depositAmount to the balance

    void withdraw(double withdrawalAmount);
    // post: Debit withdrawalAmount from the balance

    double getBalance() const;
    // post: Return this account's current balance

    std::string getName() const;
    // post: Return this account's name

  private:
    std::string name;
    double balance;
};
```

我们可以将这份`BankAccount`类的定义视作将来在C++中构建多个`BankAccount`对象的蓝图。如你所见，每个`BankAccount`对象都会有属于自己的数据成员：`name`和`balance`，以及五个意义相同的成员函数：`BankAccount`、`deposit`、`withdraw`、`getName`和`getBalance`。通常情况下，当我们在名为`BankAccount.h`的文件中做了这样的定义之后，就需要在另一个名为`BankAccount.cpp`的文件中对这个C++类做出具体的实现。

需要注意的是，C++社区中指称类属函数时使用的是*成员函数（member function）*这个术语`【译者注：此处原文为data member，译者认为是作者笔误，故修正于此，特做说明。】`，而在指称存储对象状态的变量时则使用的术语是*数据成员（data member）*。在其他编程语言中，人们通常使用*方法（method）*这个术语来指称前者，而不是*成员函数*。后者也一样，人们通常使用的术语是*实例变量（instance variable）*而不是*数据成员*。本教材将采用C++的术语风格。

另外我们也可以看到。`BankAccount`对象在构造时需要我们提供以下两个实参来初始化该对象的状态：

* 一个可以代表这个账户的标识符，譬如某个名称。
* 一个表示账户初始余额的浮点数。

**通用格式 5.1**： *构造对象（也可以同时设置初始值）*

> *class-name object-name*(*initial-value(s)*);

下面来看几个对象构造的示例：

```C++
BankAccount anAccount("Chris", 125.50);
string str("A string")
string str2() // default value is an empty string ""
```

如你所见，每个对象都具有：

* 名称：这是用来引用整个对象的变量。
* 状态：该对象当前所拥有的值。
* 消息：该对象可执行的操作。

每个对象都会提供一个用来访问该对象状态的变量，虽然它们拥有各自独特的状态，但能理解同一组消息。例如，在下面这个对象构造动作中，

```C++
BankAccount anotherAccount("Dakota", 60.00);
```

我们收到了以下信息：

* 用以范围该对象的名称：`anotherAccount`。
* 状态：”Dakota“这个账户名下的账户余额为60.00。
* 消息：该对象可以理解的消息包括`withdraw`、`deposit`、`getBalance`等。

也就是说，`BankAccount`类的其他实例理解的消息是相同的，但它们会有各自独立的状态。例如在下面这个`BankAccount`对象构造玩之后，

```C++
BankAccount newAccount("Kim", 1000.00);
```

`newAccount`对象的名称是“Kim”，账户余额为1000.00。

### 5.1.2 图解类与对象的关系

The three characteristics of objects can be summarized with a class diagram:

![图5-2](img/5-2.png)

A class diagram lists the class name in the topmost compartment. The instance variables appear in the compartment below it. The bottom compartment captures the methods. Objects can also be viewed as instance diagrams where the name of the object is underlined and values are shown:

![图5-3](img/5-3.png)

These three object diagrams describe the current state of three different BankAccount objects. One class can be used to construct many objects, each with its own separate state (set of values).

## 5.2 SENDING MESSAGES

Objects such as cin, cout and any string object have class member functions. Using them is a bit different from using the free functions such as those declared in cmath. A different syntax is required. This different type of function call is even distinguished with a different name— *message*—when using a member function. Some messages return the object’s state. Other messages tell an object to do something.

* A message that asks the object to return its state: anAccount.getBalance();
* A message that tells the object to do something: anAccount.withdraw(25.00);

The state of objects is made accessible through certain operations such as getName and getBalance. Other class member functions exist so programmers can modify the state of the object: withdraw and deposit, for example. Here is the general form used to send messages to objects:

**General Form 5.2** *Sending a message to an object*

*object-name.function-name*(*argument-list*)

Example BankAccount messages:

```C++
anAccount.deposit(237.42);
anAccount.withdraw(5);
anAccount.getBalance();
```

The following are incorrect:

```C++
anAccount.deposit();        // Missing the amount to deposit
eposit();                   // missing the object-name and .
nAccount.getBalance;        // missing ()
anAccount.withdraw("10");   // wrong class of argument
anAccount;                  // missing member function name
anAccount.withdrawal(10);   // BankAccount has no function withdrawal
```

Fortunately, failure to supply the object name, the dot, and the operation name in the proper order usually generates an error message at compile time. Also, as with any function, the compiler complains if the client code does not supply the proper arguments between parentheses. 

The BankAccount class (and therefore all BankAccount objects) has two member functions to access the state of the object: getName and getBalance. Th e BankAccount class has two member functions that modify the state—withdraw and deposit. These operations are exemplifi ed in the following program that constructs two BankAccount objects and sends messages to both of those objects. Those messages result in the following actions:

* deposit 133.33 to the object named ba1
* withdraw 250.00 from the object named ba2
* display the names and modifi ed balances of both objects

```C++
// Initialize two BankAccount objects and send some messages
#include <iostream> // for cout
using namespace std;
#include "BankAccount.h" // for class BankAccount

int main() {
    BankAccount ba1("Miller", 100.00);
    BankAccount ba2("Barber", 987.65);

    ba1.deposit(133.33);
    ba2.withdraw(250.00);

    cout << ba1.getName() << ": " << ba1.getBalance() << endl;
    cout << ba2.getName() << ": " << ba2.getBalance() << endl;

    return 0;
}
```

**程序输出**

```shell
Miller: 233.33
Barber: 737.65
```

Objects store varying amounts of data depending on the class to which they belong. Th e state of an object may require many values—and these values also may be of different classes. For example, a BankAccount object stores a string object to represent the account name, and at the same time stores a number to represent the balance. A weeklyEmployee object might store several strings such as name, address, social security number, and several numbers such as pay rate and hours worked. A robot object may store a current position, a map, and the state of its arm mechanism.

**自检题**

5-1 Each of the lettered lines has an error. Explain why.

```C++
#include <iostream> // For cout
#include "BankAccount.h" // For class BankAccount
using namespace std;

int main() {
    BankAccount b1("Sam");          // -a
    BankAccount b2(500.00);         // -b
    BankAccount b3("Jo", 200.00);   // -c
    b1.deposit();                   // -d
    b1.deposit;                     // -e
    b1.deposit("100.00");           // -f
    B1.deposit(100.00);             // -g
    b1.Deposit(100.00);             // -h
    withdraw(100);                  // -i
    cout << b4.getName() << endl;   // -j
    cout << b1.getName << endl;     // -k
    cout << b1.getName(100.00) << endl; // -l
    return 0;
}
```

5-2 Write the output generated by the following program:

```C++
#include <iostream> // For cout
using namespace std;
#include "BankAccount.h" // For the BankAccount class

int main() {
    BankAccount b1("Chris", 0.00);
    BankAccount b2("Kim", 500.00);
    b1.deposit(222.22);
    b1.withdraw(20.00);
    b2.deposit(55.55);
    b2.withdraw(10.00);

    cout << b1.getName() << ": " << b1.getBalance() << endl;
    cout << b2.getName() << ": " << b2.getBalance() << endl;
    return 0;
}
```

## 5.3 string OBJECTS

Like bankAcount, the string type is implemented as a C++ class. Although each string object stores a collection of characters, a programmer may sometimes be interested in one single character. At other times the programmer may require several characters or the current length of a string (number of characters stored). It is sometimes necessary to discover if a certain substring exists in a string. For example, is the substring ", " included in the string "Last, First" and if so, at what index does ", " begin? Th e C++ string type provides a large number of member functions to help with problems requiring knowledge of string values. You will use string objects in many programs.

Each string object stores a collection of zero or more characters. string objects can be constructed in two ways.

**General Form 5.3** *Constructing string objects in two different ways*

string *identier*(*string-literal*);
string *identier* = *string-literal*;

**Examples**

```C++
string stringReference("A String Object");
string anotherStringReference = "Another";
```

As with most classes, string has member functions that modify the state of string objects— insert, replace, erase—and member functions that return something about the state—length, nd, and substr. The string class has operations that allow access to the elements, or individual characters at, \[\], front, and back. There are also a number of operators that can be applied to string objects such as +, \[\], <<, and >>.

### 5.3.1 ACCESSING METHODS

**string::length()**

A length message sent to a string object returns the number of characters currently in the string.

```C++
string stringReference("A String Object");
string anotherStringReference = "Another";
stringReference.length(); // returns 15
anotherStringReference.length(); // returns 7
```

**string::at**

An at message returns the character located at the index passed as an int argument. Notice that string objects have zero-based indexing. The first character is located at index 0, and the second character is located at index 1, or as the message at(1).

```C++
string str("A string object");
str.at(0); // returns 'A'
str.at(1); // returns ' '
str.at(2); // returns 's'
str.at(str.length()-1); // returns 't', the last character
```

**string::find and string::rfind**

A nd message returns the index of the first character where the entire string argument is found. If the string argument does not exist, nd returns string::npos (no position), which is a very large integer that may be diff erent from the integer shown below. r nd returns the starting index of the *last* occurrence of the string argument.

```C++
string str("there is the other the");
str.find("the"); // returns 0, the first "the"
cout << str.rfind("the"); // returns 19, the last "the"
cout << str.find(" is "); // returns 5
cout << str.find("not here"); // returns string::npos which
                              // may be 18446744073709551615
```

**string::substr**

A substr message returns the part of a string starting at the index specifi ed as the fi rst argument. The second argument represents the total number of characters to the end of the string.

```C++
string str("Smiles a Lot");
str.substr(1, 4); // returns "mile"
str.substr(9, 1); // returns "L"
str.substr(9, 2); // returns "Lo"
str.substr(9, 55); // returns "Lot"
```

**str::front and str::back**

The front and back member functions provide access to the first and last characters in the string object.

```C++
string str("abc");
// front and back are part of C++11. With some C++ compilers,
// this code may generate compile time errors because their
// string class may does not yet have these member functions.
str.front(); // returns 'a'
str.back();  // returns 'c'
```

### 5.3.2 MODIFYING METHODS

**str::insert**

An insert message adds additional characters into the string object right before the character indexed by the first argument. The second argument can be a string literal or another string object.

```C++
string quick("quick");
string all("the brown jumped dog");

all.insert(4, quick); // all.length() increased
all.insert(23, "over the lazy");
cout << all; // prints: the quick brown jumped over thelazy dog
```

**str::replace**

The replace member function changes the portion of the string that begins at the index of the fi rst argument and spans the number of characters specifi ed as the second argument.

```C++
string quick("quick");
string all("the brown jumped dog");
all.replace(4, 14, quick);
cout << all; // prints: the quick dog
```

**str::erase**

An erase message erases the part of the string indicated by the indexes specifi ed in the arguments.

```C++
string all("the quick brown fox");
all.erase(4, 12);

cout << all << endl; // prints: the fox
cout << all.length(); // prints 7
```

### 5.3.3 OPERATORS DEFINED FOR string OBJECTS

**+ OPERATOR**

Programmers often make one string object from two separate strings with the + operator that concatenates (connects) two or more strings into one string.

```C++
string firstName("Kim");
string lastName("Potter");

string fullName = lastName + ", " + firstName;
cout << fullName; //prints Potter, Kim
```

Characters can also be concatenated with strings.

```C++
fullName = '>' + fullName + '<';
cout << fullName; // prints >Potter, Kim<
```

**<< AND >> OPERATORS**

The << and >> operators are overloaded for the string class to allow input and output of strings, just like numbers.

```C++
string firstName;
cout << "Enter first name: ";
cin >> firstName; // If the user enters Kim
cout << "Hello " + firstName; // output would be: Hello Kim
```

**[] OPERATOR**

The [] is like the at member function. Using square brackets, individual characters can be accessed or changed.

```C++
string str("abcde");

str[0]; // returns 'a'
str[1]; // returns 'b'
str[4]; // returns 'e'

str[2] = 'X';
str[3] = 'O';
cout << str; // prints abXOe
```

Other operators for comparing strings, such as <= and ==, will be presented in a later chapter.

**SELF-CHECK**

5-3 What is the output from the following program?

```C++
#include <iostream>
#include <string>
using namespace std; // Allows string instead of std::string

int main() {
    string str("Social Network");
    cout << str.length() << endl;
    cout << str.at(0) << endl;
    cout << str.at(str.length() - 1) << endl;
    cout << str.find("Net") << endl;
    cout << str.find("net") << endl;
    cout << str.substr(7, 3) << endl;
    cout << str.substr(7, 1) << endl;
    cout << str.substr(7, 99) << endl;
    cout << str[1] << endl
    return 0;
}
```

5-4 What is the modifi ed value of each string object?

* a.
    ```C++
    string str1("Social");
    str1.replace(0, 1, "UnS");
    ```
* b.
    ```C++
    string str3("Social");
    str3.insert(3, "iet");
    str3.erase(6, 1);
    ```
* c.
    ```C++
    string str2("Social");
    str2.erase(3, 2);
    ```
* d.
    ```C++
    string str4("Social");
    str4[0] = 'N';
    str4[5] = 'X';
    str4\[2\] = 'T';
    ```

5-5 Write the code to store the middle character of a string object into a char variable named mid. If there is an even number of characters, store the char to the right of the middle. For example, the middle character of “abcd” is ‘c’.

5-6 For each of the following messages, if there is something wrong, write “error”; otherwise, write the value of the expression.

```C++
string str("Any String");
```

* a. length(str)  
* b. str.length
* c. str(length)
* d. str.find(" ")
* e. str.substr(2, 5)
* f. str.substr("tri")

## 5.4 ostream AND istream MEMBER FUNCTIONS

The istream and ostream classes provide input and output.

**ostream::width**

The member function width modifi es the state of the ostream object named cout.

```C++
#include <iostream>
using namespace std;
int main() {
    cout << 1;
    cout.width(5);
    cout << 2;
    cout << 3;
    return 0;
}
```

**Output**

```shell
1 23
```

Normally, the state of cout is set to display the next output in the minimum number of columns—with no leading spaces—which is the default state of cout. Th e cout.width(5) message temporarily alters the state of cout such that the very next output will be output in a minimum of five columns. After that, the default situation is back in force so the 2 is printed in one column, immediately following the 3.

**ostream::precision**

To gain control over the appearance of fl oating-point output, use the ostream member function precision. A precision message tells the ostream object cout to show a specific number of digits in floating-point numbers. Unlike width, the precision remains the same until another precision message is sent to cout.

```C++
// Send two precision messages to the ostream object named cout
#include <iostream>
using namespace std;

int main() {
    double x = 1.23456;

    cout << x << endl;   // Default (1.23456)
    cout.precision(1);   // Modify the state of cout
    cout << x << endl;   // Show only one signi cant digit (1)
    cout.precision(4);   // Modify the state of cout
    cout << x << endl;   // Show four digits rounded (1.235)
    cout << x << endl;   // Precision of 4 still in effect

    return 0;
}
```

**Output**

```shell
1.23456
1
1.235
1.235
```

**istream::good**

The member function good of the istream class returns the state of an input object (usually cin). Normally, cin.good() returns 1, which means “true” if cin is still capable of reading. However, if someone enters an improper value, such as input of BAD instead of a number as shown below, the good message returns 0, which means “false.”

```C++
cout << cin.good(); // Returns 1 for good, 0 for bad
```

Whenever cin.good() is false, no more input is allowed from cin unless other steps are taken. So if you enter an invalid number—an easy input mistake to make—strange things may occur.

```C++
// Demonstrate what happens with bad input
#include <iostream> // For the cout and cin objects
using namespace std;

int main() {
    int x = 0.0;

    cout << "Is cin good? " << cin.good() << endl;
    cout << "Enter an int: ";
    cin >> x;
    cout << "Is cin still good? " << cin.good() << endl;

    return 0;
}
```

| Dialogue: 1 means true | A 2nd Dialogue: 0 means false |
|------------------------|-------------------------------|
| Is cin good? 1         |     Is cin good? 1            |
| Enter an int: 123      |   Enter an int: NotAnInt      |
| Is cin still good? 1   |   Is cin still good? 0        |

### 5.4.1 CLASS MEMBER FUNCTION HEADINGS

When a function is a member of a class, the function heading is qualified with the class name followed by the scope resolution operator ::. Using :: will be necessary to successfully build a C++ class in the next chapter. It also helps the reader determine when the dot notation is required to send a message. Any function heading of the following form identifi es the function as a class member function:

**General Form 5.4** *Class member function headings*

> *class-name* :: *function-name*(*parameters*)

So for example, int string::length() indicates that length is a member of the string class. It is diff erent from the nonmember functions sqrt and pow. Here is the list of some of class member function headings that have been revealed so far (many more exist):

**EXAMPLES OF CLASS MEMBER FUNCTION HEADINGS**

| Class        | Member function heading |
|--------------|-------------------------|
| string       | int string::length() const; <br>// Return the number of characters in this string <br>int string:: nd(string subString); <br>// Return position of first substring <br>string string::substr(int pos, int n) const; <br>// Return the n characters to the right of <br>// string[pos] or up to this string's length<br>string insert (int pos, const string& str); <br>// Inserts additional characters into the string right <br>// before the character indicated by pos. |
| ostream      | int ostream::width(int nCols); <br>// Next output to this ostream object will be <br>// displayed in nCols. Returns the current value <br>// of the date member width. <br>int ostream::precision(int nDigits); <br>// Show oating-point output with nDigits of digits. <br>// Also returns the current precision. |
| istream      | int istream::good(); <br>// post: Return 1 if istream can read or 0 if corrupt |
| BankAccount  | BankAccount::BankAccount(string aName, double initBalance); <br>// post: Construct a BankAccount with two arguments <br>void BankAccount::deposit(double amount); <br>// pre: amount >= 0 <br>// post: amount is credited to this object's balance <br>void BankAccount::withdraw(double amount); <br>// pre: amount >= 0 and <= this object's balance <br>// post: amount is debited from this object's balance <br>double BankAccount::getBalance() const; <br>// post: Return this object's current balance <br>string BankAccount::getName() const; <br>// post: Return this object's name |

The class name and :: should help you determine whether you must call a non-member (free) function without the function name first or send a message with the object name followed by a dot.

| Free Function Heading                     | Function Call            |
|-------------------------------------------|--------------------------|
| double pow(double base, double power) <br>// post: Return base to the power power | double answer = 0.0; <br>double x = 1.023102; <br>answer = pow(x, 360.0); |

| Member Function Heading                   | Message                  |
|-------------------------------------------|--------------------------|
| string string::substr(int pos, int n) <br>>// post: Return n characters of this <br>> // string beginning at index pos | string name("Doe, Jo"); <br>int n = name.find(","); <br>string last = name.substr(0, n); |

Additionally, to document a function name as a class member function requiring the dot notation, you will often see member functions referred to without the parameter list and return type such as  string::length. This is true in the context of this textbook and with most online and book documentation.

**SELF-CHECK**

5-7 Write the output generated by the following program. Make sure you line up all output in the correct column.

```C++
#include <iostream>
using namespace std;
int main() {
    cout << "123456789012345" << endl;
    cout.width(3);
    cout << 1;
    cout.width(5);
    cout << 2.3;
    cout.width(6);
    cout << "who" << endl;
    return 0;
}
```

5-8 Write the exact output generated by the following program:

```C++
#include <iostream>
using namespace std;
int main() {
    cout.precision(3);
    cout << 9.876543 << endl;
    cout.precision(1);
    cout << 1.2 << endl;
    cout.precision(8);
    cout << 1.2 << endl;
    return 0;
}
```

5-9 Write the complete dialogue generated by the following program when:

* a.  the user enters ***123***
* b.  the user enters ***XYZ***

```C++
#include <iostream>
using namespace std;
int main() {
    int anInt(0);
    cout << "Enter an integer: ";
    cin >> anInt;
    cout << "Good? " << cin.good() << endl;
    return 0;
}
```

5-10 What class does each member function belong to?

* a. istream::clear
* b. Grid::move
* c. ostream::width
* d. string::replace
* e. BankAccount::withdraw
* f. istream::good

## 5.5 ANOTHER NONSTANDARD CLASS: Grid

This section presents another nonstandard class that will be used occasionally over the next several chapters to help you think in terms of objects while providing opportunities to improve problemsolving skills.

This section presents a Grid type implemented as a C++ class. Before you study this section, please realize that the Grid class is meant to be used for teaching and learning purposes only. It will be used occasionally in later chapters to demonstrate new concepts in a visual manner. However, Grid objects are not meant to predominate any of those new concepts. The graphical state of Grid is meant to help you more readily grasp the access and modifi cation of object state through messages. You will be able to complete a few programming projects comprised only of messages to this object.

The Grid class presented here is based on the work of Rich Pattis’ *Karel the Robot: A Gentle Introduction to the Art of Programming* and a game seen at Disney World’s Epcot Center. Th e game asked the question, “Could you be a programmer?” Th e player was invited to guide a pirate ship to a treasure while avoiding obstacles.

A Grid object stores a little rectangular map of rows and columns with an object to move. A Grid object is initialized with fi ve arguments:

```C++
Grid Grid-name (rows, cols, mover-row, mover-col, direction);
```

where the first two arguments represent the size of the Grid in rows and columns, the next two arguments are the mover’s starting row and column, and the last argument is the mover’s starting direction. The direction must be listed either as north, south, east, or west.

The following program provides an example initialization with an output message(Grid::display) that allows the programmer to inspect the state of the Grid. To maintain consistency with C++, which begins counting at 0, the first row is referenced as the 0 row. The first column is also referenced as the 0 column and the intersection of the first row, first column location is referenced as 0, 0.

```C++
// Initialize and display a Grid object
#include "Grid.h" // For the Grid class

int main() {
    // Arguments used to initialize a Grid object go like this:
    // #rows, #columns, StartRow, StartColumn, StartDirection
    Grid aGrid(8, 16, 4, 8, east); // 4 is the fth and
                                   // 8 is the ninth
    column aGrid.display();
    return 0;
}
```

**Output**

```shell
The Grid:
. . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . .
. . . . . . . . > . . . . . . .
. . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . .
```

A Grid object’s state is accessed with class member functions such as these:

* int Grid::row() const
* int Grid::nRows() const
* int Grid::nColumns() const
* void Grid::display() const
* bool Grid::frontIsClear() const

Although you may not see the need for these operations at this point, they will come in handy if you do any problem solving associated with Grid objects.

```C++
// Access the state of a Grid object with messages
#include <iostream> // For the cout object
using namespace std;
#include "Grid.h" // For class Grid

int main() {
    Grid aGrid(7, 14, 5, 8, east); // Column 8 is the ninth column
    cout << "Current row : " << aGrid.row() << endl;
    cout << "Current column : " << aGrid.column() << endl;
    cout << "Number of rows : " << aGrid.nRows() << endl;
    cout << "Number of columns: " << aGrid.nColumns() << endl;
    cout << "Front is clear? : " << aGrid.frontIsClear() << endl;
    return 0;
}
```

**Output**

```shell
Current row : 5
Current column : 8
Number of rows : 7
Number of columns: 14
Front is clear? : 1
```

The state of any Grid object is modifi ed with the messages Grid::move(), Grid::turnLeft(), and Grid::turnRight().

```C++
#include "Grid.h" // For the Grid class
int main() {
    Grid aGrid(7, 9, 1, 3, east);

    aGrid.move(); aGrid.move(); aGrid.turnRight(); aGrid.move();
    aGrid.move(); aGrid.turnRight(); aGrid.move(); aGrid.move();
    aGrid.turnLeft(); aGrid.move(); aGrid.move(); aGrid.display();
    return 0;
}
```

**Output**

```shell
The Grid:
. . . . . . . . .
. . .       . . .
. . . . .   . . .
. . .       . . .
. . .   . . . . .
. . . v . . . . .
. . . . . . . . .
```

**SELF-CHECK**

5-11 Write the output of the following program:

```C++
#include <iostream> // For cout
using namespace std;
#include "Grid.h" // For the Grid class

int main() {
    Grid aGrid(6, 6, 4, 2, east);
    aGrid.move(2);
    aGrid.turnLeft();
    aGrid.move(3);
    aGrid.turnLeft();
    aGrid.move(2);
    aGrid.display();
    cout << "row: " << aGrid.row() << endl;
    cout << "col: " << aGrid.column() << endl;
    return 0;
}
```

### 5.5.1 OTHER Grid OPERATIONS

There are several other Grid operations, some of which will be needed in this chapter’s programming projects. Completing those projects provides practice at sending messages to objects—calling member functions—and developing algorithms resulting in a more graphical result. Th e following class diagram lists all Grid member functions. It is not necessary to know the data members to use objects, so the state is omitted here.

**Grid MEMBER FUNCTIONS**

```C++
// -- Modiers
void move();
void move(int spaces);
void turnLeft();
void turnRight();
void putDown();

void putDown(int putDownRow, int putDownCol); void toggleShowPath();
void pickUp();
void block(int blockRow, int blockCol);

// -- Accessors
bool frontIsClear() const;
bool rightIsClear() const;
int row() const;
int column() const;
int nRows() const;
int nColumns() const;
void display() const;
```

Although this class diagram provides a summary of legal messages, it does not explain the number and class of arguments to use when sending messages to a Grid object. For that, the following subset of the member function headings is provided (all the ones you need to do the programming projects in this chapter) with pre- and postconditions.

**SUBSET OF Grid MEMBER FUNCTIONS**

These help us understand what each function does. A precondition tells us what must be true before a message is sent. A postcondition tells us what will happen if the precondition is met.

```C++
Grid::Grid(int Rows, int Cols,
           int startRow, int startCol,
           int direction)
// post: Construct a 10-by-10 Grid object with 5 arguments
//       Grid aGrid(10, 10, 0, 0, east);

void Grid::move()
// pre: The mover has no obstructions in the next space
// post: The mover is 1 space forward

void Grid::move(int spaces)
// pre: The mover has no obstructions in the next spaces
// post: The mover is spaces forward

void Grid::putDown(int putDownRow, int putDownCol)
// pre: The intersection (putDownRow, putDownCol) has nothing at
//      it except, perhaps, the mover
// post: There is one thing at the intersection

void Grid::pickUp()
// pre: There is something to pick up at the mover's location
// post: There is nothing to pick up from the current intersection

void Grid::turnLeft() // post: The mover is facing 90 degrees counterclockwise

void Grid::block(int blockRow, int blockCol)
// pre: There is nothing at the intersection (blockRow, blockCol)
// post: The intersection can no longer be visited

void Grid::display() const
// post: The current state of the Grid is displayed on the screen
```

For example, think about a program that blocks three intersections (represented by \#), instructs a kid to eat two cookies, and moves the kid back to the starting point. A few messages to Grid::putDown will place a few “cookies” (or whatever you would like the capital letter “O” to represent) on the Grid. Then the challenge is sending the proper messages to move the kid to eat the cookies using the Grid member functions such as Grid::move. If the kid is facing south you will see a v, if the kid is facing north you will see \^, if the kid is facing east you will see > and facing west <. To "eat" the cookies send messages to Grid::pickUp. Here is the program:

```C++
// This program sets two cookies on the table and instructs a kid
// on how to locate them, "eat" them, and return home
#include "Grid.h" // For the Grid class

int main() {
    Grid kid(8, 12, 0, 0, south);
    kid.putDown(4, 0);
    kid.putDown(4, 3);
    kid.block(3, 2); // Can't move through a block #
    kid.block(4, 2);
    kid.block(5, 2);
    // Show the state of kid
    kid.display();

    // "Eat" two cookies
    kid.move(4);
    kid.pickUp();
    kid.move(2);
    kid.turnLeft();
    kid.move(3);
    kid.turnLeft();
    kid.move(2);
    kid.pickUp();

    // Get the kid back home
    kid.move(4);
    kid.turnLeft();
    kid.move(3);

    // Show the ending state
    kid.display();
    return 0;
}
```

**Output**

```shell
> The Grid
v . . . . . . . . . . .
. . . . . . . . . . . .
. . . . . . . . . . . .
. . # . . . . . . . . .
O . # O . . . . . . . .
. . # . . . . . . . . .
. . . . . . . . . . . .
. . . . . . . . . . . .

The Grid
<       . . . . . . . .
  . .   . . . . . . . .
  . .   . . . . . . . .
  . #   . . . . . . . .
  . #   . . . . . . . .
  . #   . . . . . . . .
        . . . . . . . .
. . . . . . . . . . . .
```

### 5.5.2 FAILURE TO MEET THE PRECONDITIONS

There are many “illegal” messages you can send to a Grid object. For example, you could try sending a move message that asks the mover to move through a block (\#) or off the edge of the Grid. All it takes is one incorrect message—moving four rows instead of three, for example.

**SELF-CHECK**

5-12 If you were designing the operations for a Grid object, what would you want to prevent from occurring?

So what should a Grid object do when sent a message that makes no sense? Quite frankly, it’s a bit awkward. Th e object could respond by doing nothing. In this case, the state of the object would remain unaltered. Or the object could travel off the end of the Grid or move through blocks—but this sounds more like a Superman object. Here’s yet another snippy answer: the behavior is *undefined*.

This awkwardness is circumvented by the notion of preconditions. A function’s *precondition* is what the function presumes to be true when a function is called or the message is sent. For example, the void move(int spaces) operation has the precondition that there is no block or Grid edge in the path of the mover. Also, the Grid::pickUp() message presumes there is something to pick up.

```C++
void Grid::move(int spaces)
// pre: The mover has no obstructions in the next spaces
// post: The mover is spaces forward

void Grid::pickUp()
// pre: There is something to pick up at the mover's location
// post: There is nothing to pick up from the current intersection
```

So what does happen when you violate one of these preconditions? You’ll likely fi nd out if you work on certain Grid-related programming projects.

### 5.5.3 FUNCTIONS WITH NO ARGUMENTS STILL NEED ( )

You have now seen several messages that require no arguments. If a function has no parameters, it requires no arguments. Here are two examples:

```C++
cout << aString.length() << endl;
cout << aGrid.row() << endl;
```

It should be noted, before you do any of this chapter’s programming projects, that even though no values need to be passed as arguments to either string::length or Grid::row, the parentheses must still be included in the message. The following code will not do what you might expect:

```C++
cout << aString.length << endl; // ERROR: Missing () after length
cout << aGrid.row << endl;      // ERROR: Missing () after row
```

The parentheses represent the function call operator. Without ( and ), there is no function call— even when zero arguments are needed by the function.

## 5.6 WHY FUNCTIONS AND CLASSES?

*Abstraction* is the process of pulling out and highlighting the relevant features of a complex system. One aspect of abstraction is understanding the computer from the programming-language level without full knowledge of the details at the lower levels. Abstraction is our weapon against complexity.

You can use operations such as sqrt, pow, Grid::move, and any other new function without knowing the implementation details coded by other programmers. Abstraction allows programmers to quickly and easily use int, double, string, BankAccount, and Grid objects. The characteristics of int data (a specifi c range of integer values) and int operations (such as addition, multiplication, assignment, input, and output) can be understood without knowing the details of those operations, or even how those values are stored, or how these operations are implemented in the hardware and software. Abstraction is friendly. Abstraction makes life easier. Abstraction helps keep us sane. Abstraction is that little “black box” programmers are always talking about. When you can’t see how a function is implemented, a programmer calls that a “black box.” Th at is abstraction.

Even though C++ is delivered with a large set of abstractions known as functions and classes, additional functions and classes will still be required. New abstractions are built from existing objects, operations, and algorithms. As you begin to create function and class abstractions, set a goal to build these abstractions so they are easy to use and perform a well-defi ned operation. When the details of implementation are long forgotten, you will still be able to use the abstraction because you know *what* it does. You won’t have to remember *how* it does it.

Instead of encapsulating a group of related code statements in a function, you could write all code statements directly in the main function. Th ose statements would then replace the function call. However, as the table below shows, that detailed way is quite extensive in the number of lines required.

**The Actions Represented by One Message**
| Operation                     | The Object-Oriented Way        | The Detailed Way     |
|-------------------------------|--------------------------------|----------------------|
| Construct one Grid object     | Grid g(15,15,9,4,east);        |  35 lines            |
| Move in current direction     | g.move(2);                     | 112 lines            |
| Output the Grid               | g.display();                   |   6 lines            |
| Change direction              | g.turnLeft();                  |  10 lines            |

The four messages in the middle column represent the abstract equivalent of coding the 163 lines the non-function way, as listed in the right column. Now imagine a six-message program that moves and turns three times. Th e equivalent non-function way would require approximately 366 detailed lines of code rather than the six messages!

By placing the many lines of detailed code into functions, the programmer may execute that operation with just one message or function call. Th e same message may be sent over and over again. So whenever you have code that can be used more than once in a program, it is preferable to implement that behavior within the confi nes of a free (nonmember) function or as one of many member functions available to the objects. Function calls and messages represent many hidden instructions and details. Th e programmer need not see, nor understand, all implementation details. Encapsulating code in functions also helps avoid code duplication, a sign of poorlywritten programs. *Abstraction*, *encapsulation*, and *black box* are all terms used for hiding information.

**SELF-CHECK**

5-13 Using the previous table, how many lines of code are required to initialize the state of one Grid object using the object-oriented way?

5-14 Using the previous table, how many lines of code are required to initialize the state of one Grid object when the detailed way is used (right column)?

5-15 Write a paper and pencil program that constructs a Grid object and moves it one space in all four directions: north east south west.

By partitioning low-level details into one function, the implementation need only be written once. Another advantage of functions is that the same operation can be used over and over again with a one-line message. Rather than one huge int main() { }, programs are composed of more manageable calls to nonmember (free) functions (sqrt and pow) and messages to class member functions (string::substr and Grid::move). Here are some reasons why C++ programmers use existing functions and objects to better manage the complexity of software development:

* to reuse existing code rather than write it from scratch
* to concentrate on the bigger issues at hand
* to reduce errors by writing the function only once and testing it thoroughly

In the early days of programming, programs were written as one big main program. As programs became bigger, *structured programming* techniques became popular. One major feature of structured programming was to partition programs into functions for more manageable code. Programmers found this helped people understand the program better. It is easier to maintain programs that place related processing details in an independent function. It is easier to fix a 20-line function in a program with 100 functions than it is to fi x a 2,000-line program. Other reasons for dividing a program into smaller functions include:

* placing details into a function or class makes the code easier to comprehend
* the same actions need to be achieved more than once in a program
* the function or class can be reused in other applications

With free functions, the data are passed around from one nonmember function to another. When the data are available everywhere throughout a large program, they become susceptible to accidental changes.

Now as software has become even more complex, object technology encapsulates collections of functions with the data manipulated by those functions. Developers don’t throw the data around between disparate groups of nonmember functions which would leave them open for accidental attack. As you will see in the next chapter, with object-oriented programming, data are encapsulated with the functions—nice and safe.

**Historical Progression of How Programs Are Organized into Modules**

![图5-4](img/5-4.png)

**SELF-CHECK**

5-16 What reason for using functions makes the most sense to you?

5-17 Describe one example of how abstraction helps you get through the day.

**CHAPTER SUMMARY**

* The string class has a large number of operations for manipulating all or part of a string. These include substr, nd, at, replace, and length.
* Some messages require the object name and a dot ( . ) before the member function name and arguments. Use aString.substr(2, 5) rather than substr(aString, 2, 5).
* Consider using cout.width(10) to right-justify numeric output in 10 columns (or cout.width(9) for 9 columns, and so on). The new column width starts after the output of the previous value. It does not start at the left margin.
* Class member functions are often written with the class name and the scope resolution op-erator :: to indicate the class of objects that would understand the message, so you’ll see ostream::width rather than simply width.
* Class member function headings supply the same usage information as their nonmember cousins (sqrt, pow, fmod). Th e return type is given, as is the function name and the number and class of arguments that must be used.
* Class member functions additionally are qualified with their class names, for example, void Grid::move().
* Most classes in this textbook are part of the C++ standard. The BankAccount and Grid classes are available at this textbook’s website.
* A class diagram summarizes the names of the messages understood by any instance of a class (object). The programmer needs more information to correctly send a message such as number and class of arguments. That is why some of the class member functions were shown with pre- and postconditions.
* In the 1960s, programs were written as collections of statements. By the 1970s, programs were usually collections of free functions. Starting in the 1990s, more and more programs have been collections of interacting objects, where each object is an instance of a class containing a collection of member functions. Each improvement allows more complex software to be built.
* Abstraction means the programmer can call a function or send a message without knowing the implementation details. The programmer does need to know the function name, the return type, or the number and class of arguments.

## EXERCISES

1. Write the output generated by the following program:
    ```C++
    #include <iostream>
    using namespace std;
    #include "BankAccount.h" // For class Grid

    int main() {
        BankAccount b1("One", 100.00);
        BankAccount b2("Two", 200.00);
        b1.deposit(50.00);
        b2.deposit(30.00);
        b1.withdraw(20.00);
        cout << b1.getBalance() << endl;
        cout << b2.getBalance() << endl;
        return 0;
    }
    ```

2. Write the complete dialogue of this program when the user enters this input in the order requested: MyName 100 22.22 44.44
    ```C++
    #include <iostream> // For cout and endl
    using namespace std;
    #include "BankAccount.h" // For the BankAccount class
    int main() {
        string name;
        double start, amount;
                                      // Input:
        cout << "name: ";             // MyName
        cin >> name;
        cout << "initial balance: ";  // 100
        cin >> start;

        // Construct a BankAccount
        BankAccount one(name, start);

        cout << "deposit? ";          // 22.22
        cin >> amount;
        one.deposit(amount);

        cout << "withdraw? ";         // 44.44
        cin >> amount;
        one.withdraw(amount);

        cout << "balance for " << one.getName() << " is "
                               << one.getBalance() << endl;
        return 0;
    }
    ```

3. Write the output generated by the following program:
    ```C++
    #include <iostream> // For the object cout
    using namespace std;
    #include "Grid.h" // For the Grid class
    int main() {
        Grid aGrid(6, 6, 1, 1, south);
        aGrid.putDown(2, 3); // Place thing at a specific intersection
        aGrid.block(0, 0);
        aGrid.block(5, 5);
        aGrid.move(2);
        aGrid.turnLeft();
        aGrid.putDown(); // Place thing where the mover is
        aGrid.move(3);   // located, which appears as &
        aGrid.turnLeft();
        aGrid.putDown(); // Place object where the mover is located
        aGrid.move(1);
        aGrid.turnLeft();
        aGrid.move(1);
        aGrid.display();
        cout << "Mover: row#" << aGrid.row() << " col#" << aGrid.column()
             << endl;
        return 0;
    }
    ```

4. What is the value of position?
    ```C++
    string s("012345678");
    // Initialize position to the rst occurrence of "3" in s
    int position = s.find("3");
    ```

5. What is the value of s2?
    ```C++
    string s1("012345678");
    string s2(s1.substr(3, 2));
    // assert: s2 is a substring of s1
    ```

6. What is the value of lengthOfString?
    ```C++
    string s3("012345678");
    int lengthOfString = s3.length();
    // assert: lengthOfString stores the number of characters in s3
    ```

7. Choose the most appropriate classes for each of the following from this set of classes: double, int, ostream, istream, string, BankAccount, or Grid. 
    * a. Represent the number of students in a section.
    * b.  Represent a student’s grade point average.
    * c.  Represent a student’s name.
    * d.  Represent the number of questions on a test.
    * e.  Represent a person’s savings account.
    * f.  Simulate a very limited version of the arcade game Pac-Man.
    * g.  Read input from a user.
    * h.  Display output.

8. Name two reasons why programmers use or implement functions.

9. Must a programmer understand the implementation of Grid::move to use it?

10. Answer the following questions given the member function heading:

    ```C++
    void Grid::block(int blockRow, int blockCol)
    // pre: The intersection at (blockRow, blockCol) has nothing
    //      at all on it, not even the mover
    // post: The intersection at (blockRow, blockCol) is blocked. The
    //       mover cannot move into this intersection.
    ```

    * a.  What is the member function name?
    * b.  What type does it return?
    * c.  What class does it belong to?
    * d.  Write a valid message assuming a Grid object named aGrid exists.

11. Write a complete C++ program that will initialize a BankAccount object with an initial balance of \$500.00 and your own name. Make a deposit of \$125 and a withdrawal of \$20.00. Then show the name and balance. The output should look like this:

```shell
name: Your Name
balance: 605
```

## PROGRAMMING TIPS

1. You will need author-supplied fi les to complete some programming projects. Th ese are the files included with " and " rather than < and > ("Grid.h" and "BankAccount.h", for example). Both files need to be located in the same directory (folder) as the .cpp fi le with the main function that you are writing. You can download the proper fi les from this textbook’s website.

2. Distinguish standard \#include fi les from nonstandard (user defined) files. #include standard libraries (classes and objects) with < > and nonstandard classes with " ". Here are some examples:
    ```C++
    #include <string> // For the standard string class
    #include <iostream> // For cout and cin
    using namespace std; // Required to avoid writing std::cout
    #include "BankAccount.h" // For class BankAccount
    #include "Grid.h" // For class Grid
    ```
3. Even if no arguments are required, end messages with (). Do not forget parentheses in messages that do not require arguments.
    ```C++
    cout << myAcct.balance;    // Error: This references a memory location
    cout << myAcct.balance();  // Good

4. C++ begins counting at 0, not 1. The first character in a string is referenced with subscript 0, not 1.
    ```C++
    cout << aString[0]; // Return the first character
    cout << aString\[1\]; // Return the second character
    ```

5. Don’t reference aString\[aString.length()\]. This is an attempt to reference a single value that is not in the range of 0 to aString.length()-1. In general, do not reference characters in a string that do not exist.
    ```C++
    string aString;
    aString = "This string has 29 characters";

    cout << aString[-1]; // ERROR: -1 is out of range, only use 0..28
    cout << aString[aString.length()]; // ERROR: 29 is also out of range
    ```
6. Two diff erent kinds of constructions are allowed when only one argument is required (C++11 defines another, but it is not used until later). One with parenthesis and one with the assignment operator:
    ```C++
    string state1 = "Arizona";
    string state2("Minnesota");

    int n2 = 0;
    int n1(0);

    double x2 = 0.0;
    double x1(0.0);
    ```
However, when two or more values are needed to initialize an object, use parentheses like this:
    ```C++
    BankAccount anAcct("Skyler", 23.41);
    Grid aGrid(12, 12, 0, 0, east);
    ```

7. The :: operator indicates the class to which a function belongs. The :: operator is called the “scope resolution operator.” The class name followed by :: documents a function as a member function. Any instance of that class will understand the message. Therefore, string::length documents that any string object will understand the length message. However, the class name and :: are not to be used in the message.
    ```C++
    BankAccount anAcct("Milan", 345.67);

    // Need 'object-name.functionName' not 'class-name::functionName'
    cout << BankAccount::balance(); // Invalid
    cout << anAcct.balance(); // A valid message
    ```

## PROGRAMMING PROJECTS

### 5A A LITTLE CRYPTOGRAPHY

Write a C++ program that hides a message in five words. Use one of the characters in the fi ve input strings to spell out one new word. Make up at least one other message besides these two that requires running the same program twice:

```shell
Enter ve words: ***cheap energy can cause problems***
Enter ve integers: ***4 2 1 0 5***
Secret message: peace

Enter ve words: ***programming is very complex work***
Enter ve integers: ***3 0 0 5 2***
Secret message: giver
```

### 5B LETTER I

Write the code that would go in a main function that constructs a 13-by-7 Grid object and then instructs the mover to “draw” the letter I exactly as shown (the mover could be left anywhere next to the I).

```shell
. . . . . . .
. . . . . . .
. .       . .
. . .   . . .
. . .   . . .
. . .   . . .
. . .   . . .
. . .   . . .
. . .   . . .
. . .   . . .
. .       > .
. . . . . . .
. . . . . . .
```

### 5C HURDLES

Write a function void jumpOneHurdle(Grid & g) that instructs the mover to jump one “hurdle” (the block \#). Th e main function must make five calls to this function and display the current state after each function call to jumpOneHurdle.

```C++
g.display(); // Show initial state, just after construction
jumpOneHurdle(g); g.display();
jumpOneHurdle(g); g.display();
jumpOneHurdle(g); g.display();
jumpOneHurdle(g); g.display();
jumpOneHurdle(g); g.display();
```

The first display message should show this state of the Grid object:

```shell
The Grid:
. . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . .
> . . # . . . # . . . # . . . # . . . # . . .
. . . . . . . . . . . . . . . . . . . . . . .
```

The sixth display message should show the mover has jumped five hurdles:

```shell
The Grid:
. . . . . . . . . . . . . . . . . . . . . . .
. .       .       .       .       .       . .
      #       #       #       #       # > . .
. . . . . . . . . . . . . . . . . . . . . . .
```

### 5D STAIR CLIMB

Write a function void climbStair(Grid & g) that instructs the mover to climb one step and call it enough times to climb to the top of the stairs. You will need six block messages to simulate the stairs below.

*Before*        *After*

![图5-5](img/5-5.png)

### 5E TEN String PROCESSING FUNCTIONS

Write one C++ program that uses this test driver as a main function to generate the output shown by calling ten new free functions, which are specifi ed below.

```C++
// Test drive 10 String processing functions
int main() {
    cout << "      matterAntiMatter(\"LOL\"): " << matterAntiMatter("LOL")     << endl;
    cout << "         removeEnds(\"MarkeR\"): " << removeEnds("Marker")        << endl;
    cout << "               tripleUp(\"on\"): " << tripleUp("on")              << endl;
    cout << "   splitString(\"IU\", \"owe\"): " << splitString("IU", "owe")    << endl;
    cout << "     reverse7Chars(\"1234567\"): " << reverse7Chars("1234567")    << endl;
    cout << "         halfAndHalf(\"ABcde\"): " << halfAndHalf("ABcde")        << endl;
    cout << "   nameRearranged(\"Li,Kim R\"): " << nameRearranged("Li, Kim R") << endl;
    cout << "        middleThree(\"123456\"): " << middleThree("123456")       << endl;

    // Use reference parameters instead of returning a string
    string str1("abacada");
    remove3(str1, "a");
    cout << " remove3(\"abacada\", \"a\"): " << str1 << endl;

    string str2("ornoon");
    replace(str2, 'o', 'X');
    cout << "replace(\\"ornoon\\", 'o', 'X'): " << str2 << endl;

    return 0;
}
```

**Expected Output**

```shell
    matterAntiMatter("LOL"): Anti-LOL
       removeEnds("MarkeR"): arke
             tripleUp("on"): 1)on 2)on 3)on
   splitString("IU", "owe"): IoweU
   reverse7Chars("1234567"): 7654321
       halfAndHalf("ABcde"): cdeAB
nameRearranged("Li, Kim R"): Kim R. Li
      middleThree("123456"): 345
    remove3("abacada", "a"): bcda
replace("ornoon", 'o', 'X'): XrnXXn
```

1. string antiMatter(string matter)

Everyone knows that interplanetary space travel is fueled by letting matter and antimatter mix. With this in mind, write a function antiMatter that takes a string with the name of some thing or idea. Return a string with “Anti-” prepended to it. Don’t forget the hyphen.

```shell
matterAntiMatter("Shoes") returns "Anti-shoes"
matterAntiMatter("noisy trucks") returns ""Anti-noisy trucks"
matterAntiMatter("LOL") returns "Anti-LOL"
```

2. string removeEnds(string str)

Complete method removeEnds to return a substring of the supplied string that does not have the characters at either end. Precondition: str always has at least two characters.

```shell
removeEnds ("MarkeR") returns "arke"
removeEnds ("mom") returns "o"
removeEnds ("to") returns ""
```

3. string tripleUp(string str)

Complete method tripleUp to return a string that has the argument repeated three times with 1), 2), and 3) as shown. Precondition: str.length() 1 tripleUp("top") returns "1)top 2)top 3)top"

4. string splitString(string str, string mid)

This function takes in a string of length 2 or greater, and returns a string with a space added into the middle of the string. If the string’s length is an odd number, the second half of the string will be the longer half.

```shell
splitString("IU", "owe") returns "IoweU"
splitString("ab", "_ _") returns "a_ _b"
```

5.  string halfAndHalf(string str)

Complete method halfAndHalf to return a new string that has the first half of the argument at the end and the last half of the argument at the beginning. If there are an odd number of letters, consider thelast half to have one more character than the first half before the split. Precondition: str.length() 2.

```shell
halfAndHalf("1234abcd") returns "abcd1234"
halfAndHalf("ABcde") returns "cdeAB"
halfAndHalf("Hello") returns "lloHe"
```

6. string nameRearranged(string name)

Implement nameRearranged that takes a name in the form lastName, ", " firstName, and an initial and returns a string in the form of firstName, initial, ". " and lastName.

```shell
nameRearranged("Jones, Kim R") returns "Kim R. Jones"
```

7. string middleThree(string str)

Implement middleThree so it returns the middle three characters of any string that has three or more characters. If the length of name is even, favor the right. Precondition: str.length() 3.

```shell
middleThree("Rob") returns "Rob"
middleThree("Roby") returns "oby"
middleThree("Robie") returns "obi"
middleThree("123456") returns "345"
```

8. string reverse7Chars(string str)

Implement reverse7Chars so it returns a string that is the reverse of the argument. Precondition: Th e argument str is seven characters long.

```shell
reverse7Chars("1234567") returns "7654321"
reverse7Chars("morning") returns "gninrom"
```

9. void remove3(string & str, string sub)

Implement remove3 so it modifies the string argument str such that the first three occurrences of sub are removed. Precondition: The argument sub exists at least three times in str.

```C++
string str("there is the other the");
removeThree(str, "he"); // str changes to " tre is t otr the"

string str2("to be or to be or to be");
removeThree(str2, "to "); // str2 changes to " be or be or be"
```

10. void replace(string & str, char oldC, char newC)

Implement replace to modify the string argument str so that the first three occurrences of oldC are changed to newC. Precondition: The argument oldC exists at least three times in str.

```C++
string str3("ornoono");
replace(str3, 'o', 'X'); // str3 changes to Xr nXXno
```