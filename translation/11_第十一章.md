# 第11章 泛型容器

## 前章回顾

在上一章中，我们已经学习了如何使用泛型的`vector`对象来存储一组特定类型的元素。

## 本章提要

在本章，我们将为你介绍另一个名叫`Set`的容器类，顺便回顾一下我们在`vector`处理、类定义以及成员函数实现这些议题中学到的知识。除此之外，本章还将介绍可以用于构建存储特定类型容器的C++模版机制。我希望在完成本章学习之后，你将能够：

* 构建属于自己的存储任意类型容器的元素。
* 更好地理解拥有数据成员、构造函数以及成员函数的类概念。
* 更好地了解如何开发与`vector`处理相关的函数。

## 11.1 容器类

随着我们在计算机领域研究的深入，用在探究如何管理数据集合的方法上的时间会越来越多。上一章中介绍的`vector`类只是众多为此目的设计的类中一种。这些容器类通常都具有以下特征：

* 它们的主要作用说我作为一组对象的容器。
* 它们通常会支持往容器中添加或移除对象。
* 它们通常会允许用户以各种形式访问容器中的各个元素。

接下来，本章将提供介绍`Set`容器来带大家回顾一下与类定义、成员函数实现相关的知识。但这一次，我们将借用`vector`处理算法来实现其成员函数。除此之外，我们还将学习如何让容器类只存储指定类型的对象。也就是说，该类在构造时将会有一个类型实参传递进来。

`Set`类的主要作用是存储在容器中具有唯一性的对象。通常情况下，`Set`类对象应该具备以下特征：

* 和`vector`类一样，`Set`类对象也可以存储任意类型的对象。
* `Set`类对象中的元素是不允许重复的。
* `Set`类对象中的元素不需要我们以特定顺序来维护。

`Set`对象将能理解`isEmpty`、`insert`、`remove`、`size`以及`contains`这些消息。其数据成员包含一个名为`elements`的`vector`对象，这是容器的本身。以及一个名为`n`的、用于表示该`Set`对象中当前元素数量的整数。但在具体讨论这个容器类之前，我们要先带你了解一下C++模版机制是如何让这些类中可以存储任意类型的对象的。

### 11.1.1 传递类型实参

和`x`或1.5能以实参的形式传递给函数一样，类名（也就是类型，譬如`int`、`double`、`string`、`BankAccount`等）也可以以实参的形式被传递给C++的模版机制，譬如`<int>`或`<string>`。以实参形式传递类型名可以让程序员们使用相同的容器类来存储任何一种类型的对象。这意味着我们只需要一个`Set`类，不必为每一种类型的存储设计不同的`Set`类。

C++标准模板库（STL）用模版机制实现了一些标准容器类，其中包括`vector`、`list`、`stack`‘以及`queue`。这样就不用让程序员各自针对自己面对的新类型来实现`vector`、`list`、`stack`和`queue`这些容器了，编译器会用单一的类模版来自动创建它们。

对于每个以实参形式传递的类名来说，一个新的类就会自动创建一个用于管理该类对象的容器。例如下面我们用任意类型来创建一些`Set`对象：

```C++
Set<string> ids; // Store string objects only
Set<double> nums; // Store numbers only
Set<BankAccount> accounts; // Store BankAccount objects only
```

除此之外，模版的另一个优势是我们可以用它只能插入某一种类型的对象，例如下面这些消息操作的编译：

```C++
ids.insert("c1w4");
nums.insert(123);
accounts.insert(BankAccount("c1w4", 100.00));
```

这些消息操作是不能提供编译的，因为其实参不是其自支持的正确类型（这实际上是一件好事）。

```C++
ids.insert(123); // Argument must be a string
nums.insert("c1w4"); // Argument must be a num accounts.insert(100.00); // Argument must be a BankAccount
```

### 11.1.2 模版

类型形参允许程序员将一个数据的类型传递给它所在的类，以便告知该类对象所要存储元素的类型。

**通用格式 11.1**： *类模版*

```text
template<class template-parameter>
class class_name
```

在类定义之前加上模版什么，并给出一个模版形参，该参数的作用域涵盖整个类定义。例如在C++中，`Set`模版类的定义应该是这有开始的：

```C++
template<class Type>
class Set {
    public:
    // Allow insertion of only one specic type
    void insert (Type> element);
```

`Set`类型通常会使用`Type`这个词来命名它的模版形参。例如，当`Set`类对象被构造如下时：

```C++
Set <string> names;
```

其`Type`形参就会被替换成上面尖括号之间被传递进来的类型名，在这里就是`string`。然后C++就会自动参数如下代码：

```C++
void insert(string element);
```

但是，如果我们在调用构造函数初始化`Set`对象时使用的是`int`类型的话：

```C++
Set <int> x;
```

C++自动产生代码就会是下面这样，`Type`所在之处被`int`所替代了：

```C++
void insert(int element);
```

因为`Set`被声明成了一个模版类，编译器可以用它作为一个模型构造任意数量的、可以那不同类型元素的其他`Set`类。

在这里，名为`Type`的类形参的作用域一直会延伸至类定义的结尾。这意味着`Type`可以被用在类定义的任何一处，譬如，我们可以在`public`段使用它，也可以在`private`段的数据成员中使用它。下面来看个示例，在类定义之前加上类型形参（在这里就是`Type`），对于类的模板化是至关重要的一步：

```C++
template<class Type>
class Set {
    public:
       Set();
       Type insert(Type element)
    private:
       Type key;
};
```

如你所见，该类的`public`方法`insert`只有一个`Type`形参，它只能接受 `Type`实参传递进来的值。除此之外，它还有个`Type`类型的`private`数据成员`key`，它也只能接受`Type`实参所传递的值。在声明具体对象时，这里的`Type`标识符会被替换成声明中实参指定的类型。例如，在下面的两个对象初始化动作中，我们将`s1`和`s2`分别模版化成了`double`和`string`这两种类型：

![图11-1](img/11-1.png)

下面，我们来看一个集中使用一个泛型`Set`各项功能的示例程序：

```C++
#include <iostream>
#include <string>
using namespace std;
#include "Set.h" // For> a generic (with templates) Set class

int main() {
    Set<string> names;
    cout << "After contruction, size is " << names.size() << endl; // 0
    cout << "and the Set isEmpty: " << names.isEmpty() << endl; // true

    // Add a few elements, duplicates not allowed names.insert("Chris");
    names.insert("Chris");
    names.insert("Dakota");
    names.insert("River");

    names.remove("River"); // Succeeds
    names.remove("Not here"); // No change to the Set

    cout << endl << "After 4 insert attempts and 2 remove attempts: " << endl;
    cout << "isEmpty: " << names.isEmpty() << endl; // false
    cout << "size: " << names.size() << endl; // 2
    cout << "contains(\"Chris\")? " << names.contains("Chris") << endl;
    cout << "contains(\"Dakota\")? " << names.contains("Dakota") << endl;
    cout << "contains(\"River\")? " << names.contains("River") << endl;
    cout << "contains(\"No\")? " << names.contains("No") << endl;

    return 0;
}
```

#### 程序输出（这里1代表`true`，0代表`false`）

```text
After contruction, size is 0在新元素存储进来之前是不会增加的
and the Set isEmpty: 1

After 4 insert attempts and 2 remove attempts:
isEmpty: 0
size: 2
contains("Chris")? 1
contains("Dakota")? 1
contains("River")? 0
contains("No")? 0
```

该`Set`类的优势之一，也是许多应用中很重要的一个问题，就是元素的数量可以随着`Set`类对象中的存储情况来变化。这样就不必预先判定`Set`的最大元素数量了，一个`Set`中所能存储的元素数量将仅仅取决于其存储对象的大小与内存中可用的容量。这个问题最好的答案是，`Set`中可以在内存允许的情况下存储尽可能多的对象，没有固定的最大值，所有处理这部分的逻辑都会在`insert`方法中实现。

如果要想从`Set`中删除某个对象，就必须要为该类型定义一个具有模版类型形参的相等运算符`==`。因为我们在`contains`和`remove`这两个消息定义中会用到它。下面我们就来看看`BankAccount.cpp`文件中的具体代码，我们在这里对`operator==`进行了重载，它会在`==`左边的`BankAccount`对象的`name`等于与右边实参对象的`name`相等时返回`true`。

```C++
// Overload the == operator to compare two BankAccount objects 
bool BankAccount::operator == (const BankAccount& right) const {
    return name == right.name;
}
```

这个二元运算符`==`也可以运用在`BankAccount`对象之间：

```C++
BankAccount acct1("Ali", 123.44);
BankAccount acct2("Ali", 567.88);
BankAccount acct3("Billie", 567.88);

if(acct1 == acct2 && !(acct1 == acct3)) // true
    cout << "acct1 == acct, but not acct3: " << endl;
```

#### 程序输出

```text
acct1 == acct, but not acct3
```

另外，由于这个`Set`是一个用`vector`来构造的容器，C++通常会要求`Set`的元素都有一个默认的构造函数，这个应该是一个没有形参的构造时，譬如我们在`BankAccount.cpp`中定义的这个：

```C++
// A default constructor is require if you want a collection of these
BankAccount::BankAccount() {
    name = "???";
    balance = -9.99;
}
```

### 自检题

请根据下面的对象声明来回答以下问题：

```C++
Set<int> intSet;
```

* 11-1. `intSet`中可以存储多少个整数？

* 11-2. 请编写代码打印出`intSet`中的元素数量。

* 11-3. 请编写一个消息，尝试将整数89添加到`intSet`这个整数容器中，

* 11-4. 请编写一个消息，尝试将整数89从`intSet`中删除。

***

## 11.2 `Set<Type>`类

在这一节中，我们将具体演示如何用`vector`和模版机制来实现一个`Set`类。这个`Set`对象应该：在新元素存储进来之前是不会增加的

* 是个泛型类，因为它可以以`<Type>`的形式接受任何类型的元素。
* 不预先设置最大容量——只要自由存储空间中还有一些可用内存，它就能分配到内存。

由于种种原因，`Set`类的定义只能在同一个文件中完成，而不是我们平时习惯的两个文件。这样做的主要原因是为了避免编译时错误。有一些编译器只能在所有代码都在同一个文件中时才能处理模版，用我们平时习惯的将头文件（.h）中的类定义与类的实现（.cpp）分离是不被支持的。

这里只用一个.h文件的另一个原因是这样做能让每个方法的头信息在一行内写完，至少可以避免十几行中反复地出现`template <class Type>`。 另外，也可以在每个方法定义之前省去十几个`Set::`前缀。总而言之，这个泛型（模版）的`Set`类将会在同一个`Set.h`文件中被构建，它所有的方法定义都在同一个文件中：

```C++
/**
  * Set.h
  * This is a collection class to represent sets of any type.
  * Duplicate elements are not allowed.
  */

#ifndef SET_H_
#define SET_H_

#include <vector>

template<class Type>
class Set {
```

首先，我们会将`Set<Type>`中的元素存储在一个`vector`中。除此之外，我们还会维护一个`int`变量`n`，用以记录该`Set<Type>`中所存储的元素数，当然，这些元素必须都是不重复的：

```C++
    private:
        std::vector<Type> elements;
        int n;
```

数据成员`n`将会在构造函数内被初始化为0，然后在每一次成功调用`insert`时递增1，每次成功调用`remove`时递减1。

### 11.2.1 构造函数Set()

在`Set`的构造函数中，我们将空的`Set`初始容量设置为20，当然，我们也可以将其设置得更大或更小。

```C++
// The public constructor
public:
    //--constructor
    Set() {
        elements.resize(20);
        n = 0; // This Set object has zero elements when constructed
    }
```

然后，程序员们就可以想下面这样构造`Set`对象了：

```C++
Set <double> tests;
Set <string> names;
Set <BankAccount> names;
```

### 11.2.2 bool contains(Type const& value) const

在我们使用`Set`对象时执行各项操作时，了解其中是否存在某个特定元素是个非常重要的功能。成员函数`contains`的作用就是采用一个循环按顺序对`vector`进行搜索，找到目标就立即返回`true`。

```C++
// Return true if value is in this set
bool contains(Type const& value) const {
    for (int i = 0; i < n; i++) {
        if (value == elements[i])
            return true;
    }
    return false;
}
```

如果在所有`n`个元素中都没有找到`==`指定元素的对象，该函数就会在循环终止时返回`false`，表示没有找到指定元素。

### 11.2.3 void insert(Type const& element)

由于我们要实现的容器是一个`Set`，所以在执行`insert`操作之前，我们必须先确定当前容器中不存在这个指定的元素。如果确实不存在，该`vector`才可以去检查其容量是否可以存储更多的元素。如果不够的话，我们还需要在存储新元素之前增加一下`vector`的容量。

```C++
// If element is not == to any element, add element to this Set
// The vector will be resized to hold more elements if needed.
void insert(Type const& element) {
    if (contains(element))
        return;

    // Otherwise add the new element at the end of the vector
    // First make sure there is enough capacity
    if (n == elements.size()) {
        // Add memory for 10 more elements whenever needed
        elements.resize(n + 10);
    }
    // Insert after the last meaningful element in this set.
    elements.at(n) = element;
    n++;
}
```

### 11.2.4 bool remove(Type const& removalCandidate)

`remove`方法会负责从容器中找到要删除的元素，然后用容器中的最后一个元素覆盖掉它。当然，如果在容器中没有找到`removalCandidate`这个元素，该方法就直接返回`false`。

```C++
// pre: The removalCandidate type must overload the == operator
// post: If found, removalCandidate is removed from this Set.
//
// Remove removalCandidate if found and return true.
// If removalCandidate is not in this Set, return false.
bool remove(Type const& removalCandidate) {
    // Find the index of the element to remove
    int index = 0;
    while (index < n && !(removalCandidate == elements[index])) {
        index++;
    }

    // When subscript == size() removalCandidate was not found
    if (index == n) {
        return false;
    } else { // Found it when elements[subscript] == removalCandidate.
        // Overwrite removalCandidate with the element at the largest index
        elements[index] = elements[n - 1];
        // decrease size by 1, and
        n--;
        // report success to the client code where the message was sent
        return true;
    }
}
```

### 自检题

* 11-5. 下面的代码在经过编译之后会构建出多少个不同的类？
    ```C++
    Set<string> ids;
    Set<int> studentNumber;
    Set<double> points;
    Set<double> tests;
    ```

* 11-6. 假设我们为下列三种情景各构建了一个`Set`对象，请问在经历了这三组操作之后，它们的`size()`会返回什么值？
  * a)  10次成功的插入操作，然后5次成功的删除操作。
  * b)  40次成功的插入操作。
  * c)  40次成功的插入操作，然后40次成功的删除操作。

***

## 11.3 迭代器模式

由于每个`Set`对象始终能够知道自身存储了多少个元素（`n`），所以我们可以为容器对象设计一组给定的可按顺序迭代容器中各项值的函数。并且可以使它们成为我们容器类的一部分。

本教材的`Set`类就是用迭代器方法来访问其自身所包含的对象的。我们可以用下面这段程序来演示一下客户端代码该如何迭代整个容器，而不必担心越界问题。另外，这个示例也是我们对如何为`Set<Type>`类添加那四个可访问所有元素的方法一次预演。

```C++
#include <iostream>
using namespace std;
#include "Set.h" // For a generic (with templates) Set class
#include "BankAccount.h"

int main() {
    Set<BankAccount> set; // Store set of 3 BankAccount objects
    BankAccount anAcct("Devon", 100.00);
    set.insert(anAcct);
    set.insert(BankAccount("Chris", 300.00));
    set.insert(BankAccount("Kim", 200.00));

    set.first(); // Initialize an iteration over all elements
    double total = 0.00;
    while(set.hasMore()) {
        cout << set.current().getName() << " has ";
        cout << set.current().getBalance() << endl;
        total += set.current().getBalance();
        set.next();
    }
    cout << "Total balance: " << total << endl;

    return 0;
}
```

#### 程序输出

```text
Devon has 100
Chris has 300
Kim has 200
Total balance: 600
```

如你所见，该循环的初始化语句盗用的是`first()`，它将`Set`对象的内部索引指向了容器的第一项。然后，循环测试式`hasMore()`只要为`true`，就意味着至少还有一个元素可访问。在每次迭代结束时，都会重复执行`set.next()`这条语句，让其内部索引指向容器中的下一项，直到`hasMore()`返回`false`。而在该循环内，`current()`返回的是指向容器中某个元素的引用，我们可以通过该引用来访问这个元素。

### 自检题

* 11-7. 请编写一段代码，让其从`Set<BankAccount>`任意多的元素中找出账户余额最高那一个。

***

### 11.3.1 迭代器成员函数

The Set iterator member functions exist for the sole purpose of allowing client code to access any and all of the Set elements in a sequential fashion, from the fi rst element to the last. The first() function must be called to begin the iteration to set the private data member current to refer to the first element in the Set object:

```C++
void first() {
    currentIndex = 0;
}
```

The hasMore() member function returns true if there is at least one more element to access. You will see this message used as the loop test:

```C++
while(set.hasMore())
```

The hasMore() member function compares the private data member currentIndex to return true when there is at least one more element to visit:

```C++
bool hasMore() const {
    return currentIndex < n;
}
```

The next() member function simply increments the internal index:

```C++
void next() {
    currentIndex++;
}
```

And finally, current() returns the element referred to by the internal cursor current. Notice that the return type is whatever the client code specifi ed in constructing the Set<Type>.

```C++
Type current() const {
    return elements\[currentIndex\];
}
```

## CHAPTER SUMMARY

* Classes with type parameters allow the user to pass a type name as an argument to a class. Th is allows collection classes such as vector, list, and Set to manage any type of object.

* A class template permits the compiler to create many different classes. The compiler does the work. The programmer need not implement separate StringVector, IntVector, and BankAccountVector classes, for example.

* Member functions may be implemented in one file with no separate header, while some compilers require it. This also reduces a large amount of repeated syntax. Set was built that way as will be the projects. Here is an outline of the Set class in one file with comments and the code between curly braces removed. Use this as a model for implementing the Stack and PriorityList programming projects.
    ```C++
    /*
    * File name: Set.h
    */

    #ifndef SET_H_
    #define SET_H_ 

    #include <vector>

    template<class Type>
    class Set {
        private:
            std::vector<Type> elements;
            int n;
            int currentIndex;

        public:
            Set() { }
            void insert(Type const& element) { }
            bool remove(Type const& removalCandidate) { }
            int size() const { }
            bool contains(Type const& value) const { }
            bool isEmpty() const { }
            void rst() { }
            bool hasMore() const { }
            void next() { }
            Type current() const { }
    };

    #endif /* SET_H_ */
    ```

* The Set class illustrates how a vector can be utilized as a storage mechanism in a class that provides higher-level messages such as insert and remove—no subscripts required.

* Collection classes such as Set and vector store collections of objects while providing suitable access to the elements.

* The Set class introduced the notion of iterator member functions that allow client code to traverse the entire collection without revealing the underlying structure. Sets are not ordered or indexed, so iterators are needed to visit the nodes. Other types such as vector are indexed and have the [] and at operations.

## EXERCISES

1. Use this code to answer each of the questions below:
    ```C++
    #include "Set.h"

    int main() {
        Set<double> db;
        // . . .
    ```
   * a.  How many doubles can db store?
   * b.  Write code that adds at least four unique elements to db.
   * c.  Write code that displays all elements in db on separate lines using the iterator methods.
   * d.  Write code that determines the range of values in db. Range is defined as the largest values minus the smallest.

2. Code a templated class named plus that shows what happens to two values when + is applied. You may place the class defi nition and method implementation in one fi le named Plus.h. The following code should generate the output shown in the comments:
    ```C++
    // You only need one template class
    Plus<int> a(2, 3);
    Plus<double> b(2.2, 3.3);
    Plus<string> c("Abe", "Lincoln");
    a.show(); // 5
    b.show(); // 5.5
    c.show(); // AbeLincoln
    ```
3. Write code that finds the range of integers in Set<int> intSet;. Range is defined as the largest integer minus the smallest integer.

## PROGRAMMING TIPS

1. There are many standard C++ collection classes (vector, list, stack, queue) that are more versatile and robust than our Set class. You do not need to use the Set class for any real work. The Set class was presented here as a review of class definitions and vector processing. C++ even has a generic class set. The Set class in this chapter introduced how to build generic collections using templates in one file.

2. When implementing generic collections, put all code in one file. This reduces the amount of repeated code before each member function. Some compilers require one fi le only for template classes.

3. Iteration is prevalent; sets are not. Th e iterator functions were shown to make you aware that this pattern is frequently used, while showing one way to access all elements of a collection. The syntax and method names are diff erent in the C++ Standard Template Library. Sets are not used as often as other collections such as lists, stacks, and maps.

4. Templates provide genericity. Th e value of templates can be appreciated if you realize that one only needs one template class to create a new class for any C++ type or any new type you create. As you continue your study of C++, you will see other template classes.

5. Templates provide a lot of extra syntax. Consider the following simple and incomplete collection class that stores elements like a wait line: first in, first out. Th e column on the left shows two files and oft-repeated syntax, about 80 words. The single .h file on the right column is shorter—fewer lines, fewer words, and fewer symbols such as <, >, and ::.

![图11-2](img/11-2.png)

## PROGRAMMING PROJECTS

### 11A. class Stack<Type>

Implement a generic (with templates) Stack. A Stack allows elements to be added and removed in a last-in, first-out (LIFO) manner. Stacks have an operation called push to place elements at the “top” of the stack, and another operation called pop to remove and return the element at the top of the stack. Th e only element on the stack that may be referenced is the one on the top. This means that if two elements are pushed onto the stack, the topmost element must be “popped”(removed) from the stack before the fi rst-pushed element can be referenced. Here is a Stack for storing up to 20 integers. Your program must compile and generate the output.

```C++
#include <iostream>
#include "Stack.h"
using namespace std;

int main() {
    Stack<int> intStack(20); // stack of 20 ints

    // Use intStack
    intStack.push(1);
    intStack.push(2);
    intStack.push(3);
    intStack.push(4);

    cout << "4? " << intStack.peek() << endl;
    cout << "4? " << intStack.pop() << endl;
    cout << "3? " << intStack.peek() << endl;

    cout << "isEmpty 0? " << intStack.isEmpty() << endl;
    cout << "3 2 1? ";
    while(! intStack.isEmpty()) {
        cout << intStack.pop() << " ";
    }
    cout << endl;
    cout << "isEmpty 1? " << intStack.isEmpty() << endl;

    return 0;
}
```

#### Output

```text
4? 4
4? 4
3? 3
isEmpty 0? 0
3 2 1? 3 2 1
isEmpty 1? 1
```

*Note:* See the beginning of a Queue class in the Programming Tips section of this chapter for a complete class in one .h file.

### 11B. PriorityList<Type>

This project asks you to implement a collection class PriorityList<Type> using a vector data member. This new type will store a collection of elements as a zero-based indexed list where the element at index 0 is considered to have higher priority than the element at index 1. Th e element at index size()-1 has the lowest priority. An instance of this collection class will be able to store just one type of element such as <string>. Remember that the element at index 0 is the top priority; the element at index size()-1 is the lowest priority.

```C++
PriorityList<string> todos;

todos.insertElementAt(0, "Study for the CS exam");
todos.insertElementAt(0, "Get groceries"); 
todos.insertElementAt(0, "Sleep");

for(int priority = 0; priority < todos.size(); priority++) 
    cout << todos.getElementAt(priority) << endl;
```

#### 程序输出

```text
Sleep
Get groceries
Study for the CS exam
```

Complete these methods in PriorityList<Type> so it uses a vector to store the elements.

```C++
// Construct an empty PriorityList with capacity to store 20 elements
PriorityList();

// Return the number of elements currently in this PriorityList
int size();

// Return true if size() == 0 or false if size() > 0
bool isEmpty();

// Insert the element at the given index. If the vector
// is too small, resize it.
// precondition: index is on the range of 0 through size() 
void insertElementAt(int index, Type el);

// Return a reference to the element at the given index.
// precondition: index is on the range of 0 through size()-1
Type getElementAt(int index);

// Remove the element at the given index.
// precondition: index is on the range of 0 through size()-1
void removeElementAt(int index);

// Swap the element located at index with the element at index+1.
// Lower the priority of the element at index size()-1 has no effect.
// precondition: index is on the range of 0 through size() 
void lowerPriorityOf(int index);

// Swap the element located at index with the element at index-1.
// An attempt to raise the priority at index 0 has no effect.
// precondition: index is on the range of 0 through size() 
void raisePriorityOf(int index);

// Move the element at the given index to the end of this list.
// An attempt to move the last element to the last has no effect.
// precondition: index is on the range of 0 through size()-1
void moveToLast(int index);

// Move the element at the given index to the front of this list.
// An attempt to move the top element to the top has no effect.
// precondition: index is on the range of 0 through size()-1
void moveToTop(int index);
```

To help you understand how these methods work, consider the program below which shows the changing list as each of the messages is sent to the list. *Recommended:* implement one method at a time, and write tests to ensure that it works.

```C++
#include <iostream>
#include <string> // Needed by Visual Studio
#include "PriorityList.h"
using namespace std;

int main() {
    PriorityList<string> list;
    list.insertElementAt(0, "a");
    list.insertElementAt(1, "b");
    list.insertElementAt(2, "c");
    list.insertElementAt(3, "d");

    for (int i = 0; i < list.size(); i++) // a b c d
        cout << list.getElementAt(i) << " ";
    cout << endl;

    list.insertElementAt(1, "f");
    for (int i = 0; i < list.size(); i++) // a f b c d
        cout << list.getElementAt(i) << " ";
    cout << endl;

    list.removeElementAt(0);
    for (int i = 0; i < list.size(); i++) // f b c d
        cout << list.getElementAt(i) << " ";
    cout << endl;

    list.lowerPriorityOf(3); // no effect
    list.lowerPriorityOf(0); // move f right
    list.lowerPriorityOf(1); // move f right
    list.lowerPriorityOf(2); // move f right
    for (int i = 0; i < list.size(); i++) // b c d f
        cout << list.getElementAt(i) << " ";
    cout << endl;

    list.raisePriorityOf(0); // no effect
    list.raisePriorityOf(2); // move d left
    list.raisePriorityOf(1); // move d left
    for (int i = 0; i < list.size(); i++) // d b c f
        cout << list.getElementAt(i) << " ";
    cout << endl;

    list.moveToLast(list.size() - 1); // no effect
    list.moveToLast(0); // move d from top priority to last priority
    for (int i = 0; i < list.size(); i++) // b c f d
        cout << list.getElementAt(i) << " ";
    cout << endl;

    list.moveToTop(0); // no effect
    list.moveToTop(2); // move f to top priority again
    for (int i = 0; i < list.size(); i++) // f b c d
    cout << list.getElementAt(i) << " ";

    return 0;
}
```

### 11C PriorityList<Type> THROWS EXCEPTIONS

*Optional:* Change your code so it throws an exception when the index is out of range. To do this, first add this \#include to PriorityList<Type>:

```C++
#include <stdexcept>
```

Then add an if statement to every method that takes index as a parameter. An exception will be thrown if the programmer supplies an incorrect index like -1 or an index size(), which is a good thing:

```C++
// Insert the element at the given index.
// precondition: index is on the range of 0 through size() 
void insertElementAt(int index, Type element) {
    if (index < 0 || index > size()) {
        throw std::invalid_argument(
              "\ninsertElementAt: index must be 0..size()");
    } // . . .
```
