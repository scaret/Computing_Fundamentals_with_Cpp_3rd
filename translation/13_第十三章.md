# 第13章： 存储vector的vector（二维数组）

## 前章回顾

到目前为止，我们已经掌握了实现任意算法所需要的控制结构，也学会了如何在构建程序的过程中使用自由函数和编写独立的类。这些知识和经验将会有助于你理解本章的代码。当然，前两章所介绍的`vector`也同样会对你理解这些代码有所帮助。

## 本章提要

在本章，我们将介绍一种用两个下标来管理类似以表格行列形式存储的数据逻辑。这种存储和管理数据的方式对于像电子表格、游戏、地形图、成绩册以及其他以行和列为最佳数据呈现形式的应用程序来说是很有帮助的。另外，我们在本章还会带你再回顾一下C++中类的构造函数，用代码示范一下如何通过数据成员来研究某一主题执行的类设计。我们希望在学习完本章内容之后，你将能够：

* 对存储`vector`的`vector`中（行列形式）的数据执行相关的处理。
* 使用嵌套型`for`循环。

## 13.1 存储vector的vector

对于要以表格形式来呈现自己的数据来说，存储`vector`的`vector`对象无疑是一个不错的表示方式。

**通用格式 13.1**： *构造存储vector的vector*

```text
vector <vector<type> > identifier(rows,
    vector<type> (cols, initialValueoptional));
```

下面来具体示范一下该构造动作：

```C++
vector <vector<double> > table(4, vector<double> (8, 0.0)); // 32 zeros
vector <vector<string> > name(5, vector<string> (100, "TBA")); // 500 TBAs
```

对存储`vector`的`vector`中各个元素的引用需要用到两个下标，一个下标代表行，另一个代表列。这种数据结构还有另外一个名称，叫做*二维（2D）数组*。

**通用格式 13.2**：*访问个别元素*

```text
vectorName[row][column]
```

如你所见，这里每个下标都必须有一个单独的中括号。程序员有责任确保每个下标都在有效范围内。这双下标引用的第一个下标代表的是行，第二个下标代表的是列。

*嵌套型循环*常常会被用来处理与二维数组相关的数据。在下面的代码中，存储`vector`的`vector`中一开始存储的是15个垃圾值。我们用一个嵌套型循环将其中所有的元素分别初始化成了1到15的整数：

*请记得给旧版本的C++保留一点空间。*

```C++
vector <vector<int> > nums(3, vector<int> (5));

int count = 1;
for(int row = 0; row < nums.size(); row++) {
    // Initialize one row
    for(int col = 0; col < nums[row].size(); col++) {
        nums[row][col] = count;
        count++;
    }
}
```

![图13-1](img/13-1.png)

### 自检题

* 13-1. 哪种类型更适合用来管理数据列表，是`vector`还是存储`vector`的`vector`？

* 13-2. 哪种类型更适合用来管理以行列形式呈现的数据，是`vector`还是存储`vector`的`vector`？

* 13-3. 请构造一个存储`vector`的`vector`对象，名称为`sales`。其中要分10行存储120个数字。

* 13-4. 请构造一个存储`vector`的`vector`对象，名称为`sales`。其中要分10列存储120个数字。

***

## 13.2 Matrix类

在数学中，*矩阵（matrix，复数形式是matrices）* 是一种矩形向量，它会以行和列形式呈现一系列数字、符号和表达式，并能以某种特定方式来处理。其中一种处理方式就是获取矩阵的*阶数（order）*状态。例如，下面这个矩阵的阶数说明它是一个2 x 2的矩阵，因为它有两行两列：

$$
  \begin{bmatrix}
  12 & 4 \\
  –1 & 9
  \end{bmatrix}
$$

矩阵中的各项值通常被称之为矩阵的*元素*或*项目*.

矩阵在大多数科学领域中都有应用，其中包括物理学的各个分支，譬如传统力学、光学、电磁学、量子力学和量子电动学等，以及各种物理现象的研究，譬如刚体运动等。另外在计算机图形学方面，矩阵也常被用来将三维影像投射到二维的屏幕上。在概率论与统计学方面，我们在描述概率集时经常会需要用到随机矩阵。例如，在被Google搜索用来对页面进行排序的PageRank算法中就有使用到它们。

我们可以用C++的类机制来为矩阵建模，方法是利用存储`vector`的`vector`来存储矩阵元素，并维护该矩阵的行数和列数。在下面的头文件中，我们就定义了一个特定的`matrix`类型（当然，除此之外还有各种可能的不同设计）：

```C++
// File name: Matrix.h
#ifndef MATRIX_H_
#define MATRIX_H_
#include <vector>

class Matrix {
    private:
        int rows, columns;
        // Make sure there is a space between > and >
        //                           ||
        std::vector<std::vector<int> > table;

    public:
        // Construct a new Matrix and read data from an input file
        Matrix(std::string leName);

        // Construct a new Matrix given a vector of vectors
        Matrix(const std::vector<std::vector<int> > & vecOfVecs);

        // Return a string representation of this object.
        std::string toString();

        // Multiply each element by val
        void scalarMultiply(int val);

        // Return the sum of this Matrix + other
        Matrix add(Matrix other);
};
#endif // MATRIX_H_
```

在只需要少量数据的程序中，通常使用交互式输入就足够了。`vector`对象的初始化往往要面向的是大量的数据。因此，这些数据通常需要外部文件来提供。下面我们来看一个外部输入文件的示例。在这个整数文件`matrix.data`的第一行，我们指定了该文件要输入矩阵的行数和列数：

```text
  3 4
  6 7 8 9
  4 5 6 7
  8 7 7 8
```

剩下的每一行都代表着一位学生的测验成绩。我们接下来就要用这个小型的输入文件来演示一下如何利用存储`vector`的`vector`来处理矩阵。

首先，我们要在构造函数中将该外部文件与`ifstream`对象`inFile`关联起来。然后用输入语句将该文件第一行指定的行数和列数（3和4）读取出来，并根据读取到的数据来调整其`vector`的行数和列数。由于存储`vector`的`vector`的内存是在运行时动态分配的，并且采用的C++类的构建方式，所以这是个必要的操作。只有这样，我们才能构建一个足够大的矩阵，用以存储三行数据，每行是一个包含四个整数的`vector`。最后，我们会在一组嵌套型循环（即一个循环中嵌套着另一个循环）中用输入文件中的数据初始化这些`vector`。上述所有操作都将被封装在`Matrix.cpp`文件的`Matrix`类的构造函数中：

```C++
/*
 * Matrix.cpp
 */
#include <string>
#include <fstream>
#include "Matrix.h"
using namespace std;

// Constructs a new object and reads data from
// the input le specified as the leName argument.
Matrix::Matrix(string leName) {
    rows = columns = 0; // Avoid a warning from one compiler
    // Make sure the le named lename is stored in the same directory
    ifstream inFile( leName);
    inFile >> rows >> columns;

    // Resize the vector of vectors to any capacity at runtime (dynamically).
    table.resize(rows, vector<int>(columns));

    // Initialize the vector of vectors from file input
    for (int row = 0; row < rows; row++) {
        for (int col = 0; col < columns; col++) {
            inFile >> table[row][col];
        }
    }
}
```

与`vector`对象一样，使用输出显示矩阵中所有完成了初始化的元素是一种可以预防错误的反bug技术。下面是`Matrix::toString`方法利用嵌套型循环的帮助回显输入数据的实现：

```C++
string Matrix::toString() {
    string result("");
    // Concatenate all elements into one string
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < columns; j++) {
            result = result + std::to_string((int) table[i][j]) + " ";
        }
        result = result + "\n"; // new line"
    }
    return result;
}
```

下面，我们写一段程序来具体执行初始化和输出显示的过程：先用从文件输入的数组逐个初始化矩阵中的元素，然后输出显示存储在矩阵中的数据：

```C++
#include "Matrix.h"
#include <iostream>
using namespace std;

int main() {
    Matrix m("matrix.data");
    cout << m.toString();
    return 0;
}
```

#### 程序输出

```text
6 7 8 9
4 5 6 7
8 7 7 8
```

如你所见，`Matrix`对象得到了正确的初始化并存储了12个整数。

### 13.2.1 标量乘法

*标量乘法（Scalar multiplication）* 是`vector`与标量之间的乘法运算，它们的乘积依然是一个`vector`。这个运算可以实现为下面这个会改变`Matrix`对象状态的方法：

```C++
void Matrix::scalarMultiply(int val) {
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < columns; j++) {
            table[i][j] *= val;
        }
    }
}
```

在该运算中，矩阵的每个元素都是乘法的实参，所以下面这段代码的输出如下：

```C++
m.scalarMultiply(3);
cout << m.toString() << endl;
```

#### 程序输出

```text
18 21 24 27
12 15 18 21
24 21 21 24
```

### 13.2.2 矩阵加法

*矩阵加法（Matrix addition）* 指的是两个被相加的矩阵中的各相应项相加：

$$
  \begin{bmatrix}
  12 & 4 \\
  –1 & 9
  \end{bmatrix}
   +
  \begin{bmatrix}
   7 & –2 \\
   5 & –4
  \end{bmatrix}
   +
  \begin{bmatrix}
   19 & 2 \\
   4  & 5
  \end{bmatrix}
$$

为了让下面的代码能返回一个新的矩阵，

```C++
Matrix a("a.data");
Matrix b("b.data"); // Uses another input le to initialize Matrix c = a.add(b);
```

我们需要编写第二个构造函数，该构造函数要以存储`vector`的`vector`对象为实参来构造矩阵。下面就是这第二个构造函数，它会接收一个存储`vector`的`vector`，采用的是`const`引用类型的形参：

```C++
// Construct a new Matrix object given a vector of vectors
Matrix::Matrix(const std::vector<std::vector<int> > & vecOfVecs) {
    rows = vecOfVecs.size();
    columns = vecOfVecs[0].size();
    table = vecOfVecs;
}
```

这样，`add`操作就可以通过调用该构造函数来返回一个新的`Matrix`对象了：

```C++
Matrix Matrix::add(Matrix other) {
    vector<vector<int> > temp(rows, vector<int>(columns));
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < columns; j++) {
            temp[i][j] += table[i][j] + other.table[i][j];
        }
    }
    Matrix result(temp); // Use the second constructor
    return result;
}
```

接下来，请用输入文件来表示上述三个矩阵，下面的代码将会产生如下输出：

```C++
cout << "Matrix a: " << endl << a.toString() << endl;
cout << "Matrix b: " << endl << b.toString() << endl;
cout << "Matrix c: " << endl << c.toString() << endl;
```

#### 程序输出

```text
Matrix a:
12 4
-1 9

Matrix b:
7 -2
5 -4

Matrix c:
19 2
 4 5
```

### 自检题

* 13-5. 在逐行处理数据的过程中，是哪一个下标的增速较慢？行数还是列数？

* 13-6. 在逐列处理数据的过程中，是哪一个下标的增速较慢？行数还是列数？

  请基于下面这个2 × 2的矩阵回答下列问题：

$$
  \begin{matrix}
   12 & 4 \\
   -1 & 9
  \end{matrix}
$$

* 13-7. 请完成下面的`get`方法，返回指定行和列的元素，譬如`Matrix.get(1, 0)`将返回-1。
    ```C++
    // Assume get is in class Matrix
    int Matrix::get(int row, int column) {
    ```

* 13-8. 请完成下面的矩阵成员`sum`方法，返回矩阵中所有元素之和，譬如上述2 x 2矩阵的元素之和是24。
    ```C++
    // Assume sum is in class Matrix
    int Matrix::sum() {
    ```
***

### 13.3 原生的二维数组

上述逐行和逐列处理数据的概念也同样适用于用两个下标声明的原生C数组。换而言之，原生的C数组也可以用两个用中括号括住的，分别代表行数和列数的下标来声明。例如，下面声明的`x`中存储了10行5列的数据，总计50个数字；

```C++
double x[10][5]; // Row subscripts 0...9, column subscripts 0...4
```

这其中另一个重要的区别是，原生的C数组是没有下标越界检查的。下面，我们可以用一张表来对比一下之前的`Matrix`类和用两个下标声明的原生C数组：declared with two subscripts:

|          | 存储`vector`的`vector` | 原生C数组 |
|----------|-------------------|--------------------|
| 通用格式 | vector <vector<type> > identifier (rows, vector<type>(columns)); | type identifier[rows][columns]; |
| 实例示范 |        vector <vector<int> > unitsSold(4,vector<int>(6)); |  int unitsSold[4][6]; |
| 越界检查 | 支持 | 不支持 |
| 调整大小   | 支持 | 不支持 |
| `#include`指令 | `#include <vector>` | 不需要 |

如你所见，在名为`unitsSold`的存储`vector`的`vector`对象中，管理着4行6列的整数（一共24个整数），而在同名的原生C数组中也管理着相同下标范围内、的相同数量的整数（上述声明中右边下标代表行数）。两者之间的不同之处包括了原生C数组不支持下标的越界检查。无论我们使用的是原生C数组还是存储`vector`的`vector`对象，我们引用个别数组元素的方式是一样的。这两种数据结构的下标都始终是从0开始计数的。也就是说，下面这段代码可以同时适用于存储`vector`的`vector`和双下标的原生C数组：

```C++
int unitsSold[4][6];
// vector<vector<int> > unitsSold(4, vector<int>(6));

for (int r = 0; r < 4; r++) {
    for (int c = 0; c < 6; c++)
        unitsSold[r][c] = r + c;
}

for (int r = 0; r < 4; r++) {
    for (int c = 0; c < 6; c++) {
        cout << unitsSold[r][c] << " ";
    }
    cout << endl;
}
```

#### 使用存储`vector`的`vector`和双下标的原生C数组都会产生的输出

```text
0 1 2 3 4 5
1 2 3 4 5 6
2 3 4 5 6 7
3 4 5 6 7 8
```

### 自检题

请基于下面的声明回答下列问题：

```C++
 int a[3][4];
```

* 13-9. `a[0][0]`的值是什么？

* 13-10. 它会执行下标检查吗？

* 13-11. `a`中确切管理着多少个`int`元素？

* 13-12. `a`的行下标（即第一个下标）的范围是什么？

* 13-13. `a`的列下标（即第二个下标）的范围是什么？

* 13-14. 请编写一段代码，将`a`中所有元素初始化成999。

* 13-15. 请编写一段代码，逐行输出`a`中的所有元素，每个元素之间间隔八个空格。

***

## 13.4 拥有两个以上下标的数组

虽然拥有两个以上下标的数组没有单下标和双下标数组那么常见，但在某些情况下，我们也会需要用到三个下标（甚至更多）的数组。由于C++对下标没有限制，所以声明一个三个下标的数组并不难，譬如：

```C++
double q[3][11][6]
```

上面声明的数组可以用来表示三门课的测验成绩。由于有198（3 × 11 × 6）个成绩要存储在同一个名为`q`的数组中，所以在这个三下标的对象中：

```C++
q[1][9][3]
```

上面引用的是课程索引值为1、学生索引值为9、测验索引值为3的那个成绩。在下面的程序中，我们要对一个三下标的数组进行初始化（使用的是无意义的数据），在此过程中，我们会看到代表成绩的第一个下标是变化最慢的那一个。所以，这个数组对象的初始化和输出显示都是以课程的顺序来逐个进行的：

```C++
// Declare, initialize, and display a triply subscripted vector
// object. The primitive C subscripted object is used here, but we
// could also use a vector of Matrix objects to do the same thing.
#include <iostream>
using namespace std;

int main() {
    const int courses = 3;
    const int students = 11;
    const int quizzes = 6;
    int q[courses][students][quizzes];

    for (int c = 0; c < courses; c++) {
        for (int row = 0; row < students; row++) {
            for (int col = 0; col < quizzes; col++) {
                // Give each quiz a value using a meaningless formula
                q[c][col][row] = (col + 1) * (row + 2) + c + 25;
            }
        }
    }

    for (int course = 0; course < courses; course++) {
        cout << endl;
        cout << "Course #" << course << endl;
        for (int row = 0; row < students; row++) {
            cout.width(3);
            cout << row << ": ";
            for (int col = 0; col < quizzes; col++) {
                cout.width(4);
                cout << q[course][col][row];
            }
            cout << endl;
        }
    }
    return 0;
}
```

#### 程序输出（每一行代表一个学生）

```text
Course #0
  0: 27 33 41 49 57 65
  1: 28 34 43 52 61 70
  2: 29 35 45 55 65 75
  3: 30 36 47 58 69 80
  4: 31 37 49 61 73 85
  5: 32 39 46 53 60 67
  6: 33 41 49 57 65 73
  7: 34 43 52 61 70 79
  8: 35 45 55 65 75 85
  9: 36 47 58 69 80 91
 10: 37 49 61 73 85 97

Course #1
  0: 28 34 42 50 58 66
  1: 29 35 44 53 62 71
  2: 30 36 46 56 66 76
  3: 31 37 48 59 70 81
  4: 32 38 50 62 74 86
  5: 33 40 47 54 61 68
  6: 34 42 50 58 66 74
  7: 35 44 53 62 71 80
  8: 36 46 56 66 76 86
  9: 37 48 59 70 81 92
 10: 38 50 62 74 86 98

Course #2
  0: 29 35 43 51 59 67
  1: 30 36 45 54 63 72
  2: 31 37 47 57 67 77
  3: 32 38 49 60 71 82
  4: 33 39 51 63 75 87
  5: 34 41 48 55 62 69
  6: 35 43 51 59 67 75
  7: 36 45 54 63 72 81
  8: 37 47 57 67 77 87
  9: 38 49 60 71 82 93
 10: 39 51 63 75 87 99
```

## 本章小结

* 双下标的`vector`和C++原生的二维数组都属于以类似表格的行列组织逻辑来管理数据的数据结构。

* 在这种数据结构中，第一个下标指定的是数组在表格中行数，第二下标代表的是数据所在的列数。

* 存储在该数据结构中的数据是可以按逐行或逐列的形式来处理的。

* 这种数据结构的数据处理时经常会需要用到嵌套型的`for`循环。

* 原生的二维数组是不支持下标检查的，这有可能会带来各种错误。`vector`提供了支持下标检查的`at`方法，我们可以使用`nums.at(5).at(20);`这样的调用来引用第6行的第21个元素。

## 练习题

1. 对于下面每个双下标对象的声明，请确定以下信息：
   * a.  它们的总元素数。
   * b.  所有元素的值。
    ```C++
    vector<vector<string> > teacher(5, vector<string>(7, "to hire"));
    vector<vector<double> > quiz(10, vector<double>(32, 0.0));
    vector<vector<int> > nums(10, vector<int>(10, -999)); double budget[6][100];
    ```

2. 请检查下面这些双下标`vector`声明是否有错：
   * a.  `int x(5,6);`
   * b.  `double x[5,6];`
   * c.  `vector<vector<int> > x(5, 6)`;

3. 请声明一个双下标的对象，以代表3行4列的一组浮点数。

4. 请用编写C++代码的方式完成以下任务：
   * a.  请声明一个名为`aTable`的双下标对象，并用它来存储10行14列的浮点数。
   * b.  将`aTable`中的每个元素都设置成0.0。
   * c.  请编写一个`for`循环，将`aTable`的第4行所有元素设置成-1.0。

5. 当程序的会话是以下各种情况时，请问下面这段程序的输出分别是什么？
    ```text
        a.  # rows? ***2***     d. # rows? ***1***
            # cols? ***3***        # cols? ***1***
        b.  # rows? ***3***     e. # rows? ***1***
            # cols? ***2***        # cols? ***2***
        c.  # rows? ***4***     f. # rows? ***2***
            # cols? ***4***        # cols? ***1***
    ```

    ```C++
    #include <iostream>
    #include <vector>
    using namespace std;

    int main() {
        int maxRow, maxCol;
        cout << "# rows? ";
        cin >> maxRow;
        cout << "# cols? ";
        cin >> maxCol;
        vector<vector<int> > aTable(maxRow, vector<int>(maxCol, -999));

        // Initialize Matrix elements
        for (int row = 0; row < maxRow; row++) {
            for (int col = 0; col < maxCol; col++) {
                aTable[row][col] = row * col;
            }
        }

        // Display table elements
        for (int row = 0; row < maxRow; row++) {
            for (int col = 0; col < maxCol; col++) {
                cout.width(5);
                cout << aTable[row][col];
            }
            cout << endl;
        }
        return 0;
    }
    ```
   请根据下面的类定义来回答后面第6到第9个问题：
    ```C++
    class huh {
        public:
            huh(int initLastRow, int initLastColumn);
            void add(int increment);
            void show() const;
            int rowSum(int currentRow) const;
        private:
            int lastRow, lastCol;
            std::vector <std:vector<int> > m;
    };

    huh::huh(int initLastRow, int initLastColumn) {
        lastRow = initLastRow;
        lastCol = initLastColumn;
        // The vector of vectors must be initialized in the constructor.
        // Use a resize message with two arguments to avoid a loop for each row.
        m.resize(lastRow, vector<int>(lastCol));

        for(int row = 0; row < lastRow; row++) {
            for(int col = 0; col < lastCol; col++) {
                // Give each item a meaningless formula
                m[row][col] = (row + 1) + (col + 1);
            }
        }
    }

    void huh::show() const {
        int row, col;
        for(row = 0; row < lastRow; row++) {
            for(col = 0; col < lastCol; col++) {
                cout.width(4);
                cout << m[row][col];
            }
            cout << endl;
        }
    }
    ```

6. 请写出下面程序预计会产生的输出：
    ```C++
    int main() {
        huh h(1, 2);
        h.show();
        return 0;
    }
    ```

7. 请写出下面程序预计会产生的输出：
    ```C++
    int main() {
        huh h(3, 7);
        h.show();
        return 0;
    }
    ```

8. 请为该类完成成员函数`huh::rowSum`的实现，该函数会返回指定行中所有元素之和。它应该让下面这段程序产生的输出为22。
    ```C++
    int main() {
        huh h(4, 4);
        cout << h.rowSum(2);
        return 0;
    }
    ```

9. 请为该类完成成员函数`huh::showDiagonal`的实现，该函数会打印出该数组对角线上的所有元素。假设其行数与列数相等， 下面左侧的程序就应该产生右侧的输出。*提示：* 你在这里应该用`cout.width`方法设置一下相关的缩进。
    ```C++
    int main() {
        huh h(4, 4);
        h.showDiagonal();
        return 0;
    }
    ```
   **程序输出**
    ```text
    2
      4
        6
          8
    ```

10. 请为`Matrix`类添加一个名为`transpose`的成员函数，并实现矩阵的转置。所谓矩阵的转置就是将矩阵原来的行变成列，原来的列变成行。在此过程中，我们会需要构造一个临时的、存储`vector`的`vector`对象。

    例如，如果矩阵原本是这样的话：
    ```text
    1  4
    2  5
    3  6
    ```
    在该操作完成之后，矩阵就应该是这样：
    ```text
    1 2 3
    4 5 6
    ```

## 编程小技巧

1. 在构造存储`vector`的`vector`时，请注意，有些编译器是不允许在调用构造函数的语句中出现`>>`这种写法的。
    ```C++
    vector<vector<int>> error(10, vector<int> (10, -1));
    // Error: Need space between > and >
    ```

2. 在使用存储`vector`的`vector`的时候，尤其是在刚学习双下标用法的阶段，请优先考虑支持下标越界检查的成员函数`vector::at`。标准的`vector`类是不会自动进行下标检查的，但我们可以用它的成员函数`vector::at`来完成这个操作。
    ```C++
    vector<vector<int> > aTable(3, vector<int> (3, -1));
    aTable.at(2).at(3) = 23; // Column 3 out of bounds
    aTable.at(3).at(2) = 32; // Row 3 out of bounds
    cout << aTable.at(0).at(0); // Output: -1
    ```
   在程序中出现越界的下标变量是很常见的，我们越早发现这个错误就越有利。有了上述越界检查机制，我们就能立即知道这些错误的存在了。

3. 适用于单下标的很多编程技巧也适用于双下标和三下标的对象：
   * 任何`vector`中的元素都必须属于同一个类。例如，一个矩阵中不能同时存储字符串和整数值。
   * 任何占用大量内存的对象都应该以`const`引用的形式来传递。和单下标`vector`一样，矩阵保存在内存中并用来复制的只是一个值（该矩阵的地址）。但是，当矩阵被传递给一个值传递的形参时，其中的每个元素都会被复制，这会降低程序的效率。也就是说，下面这个调用的效率：
        ```C++
        void function(const Matrix<double> & m) // Pass by const reference
        ```
     显然要比下面这个调用好：
        ```C++
        void function(Matrix<double> m)
        ```

   * 下标的越界检查也是在使用双下标对象时应该要记得执行的操作。

## 编程项目

### 13A. 魔方问题

魔方是一种`n × n`的存储`vector`的`vector`，其中存储的整数在1到$n^2$之间，且每个数只能出现一次。在这里，`n`必须是一个正整数（譬如1、3、5等）。另外，该魔方每一行、每一列以及两条对角线上的元素之和都是相等的。我们要求你实现这样的一个`MagicSquare`类，它应该有构造函数和`display`这两个成员函数，并且你的实现应该让下面代码产生对应的输出：

![图13-2](img/13-2.png)

你应该可以在1到15之间任意选择一个奇数，并以该数为`n`的值来构造出`n × n`的魔方。当计数器`j`为1时，将`j`的值放在首行的中间。然后，在该计数器从1递增到$n^2$的过程中，其存储的数字被放置的位置都会较之前上移一行，并右移一列。除非发生了下面列出的其中一种状况：

1. 当下一行为0时，`n-1`行就自动成为该行的下一行。
2. 当下一列为`n`时，0列就自动成为该列的下一列。
3. 如果某个位置已经被填了，或者其右上角元素刚刚被赋予了某个值，那么该计数器的下一个值就会被放在最近的这个计数器值的下一行位置上。

如果在上述过程中需要调整这个方阵实例的大小，你可以这样做：

```C++
// An instance variable
vector<vector<int> > magic;
// Resize the vector to be a size by size vector
magic = vector<vector<int> >(size, vector<int>(size));
```

### 13B. 生命游戏

生命游戏（The Game of Life）是John Conway发明的一款游戏，它模拟的是个体在社区中的生死逻辑。具体来说就是，某社区中的个体在两个连续时间段之间的生和/或死将遵守以下规则，在时间`T`上：

* 如果在时间`T-1`上没有个体活着，而其周围活着三个邻居，就会有个体出生。
* 如果在时间`T-1`上已经有个体活着，并且其周围也活着两三个邻居，那么该个体就会继续活下去。
* 如果在时间`T-1`上某个体的邻居少于两个，该个体就会死亡。
* 如果在时间`T-1`上某个体的邻居超过三个，该个体会因过度拥挤而死亡。

在这里，邻居指的是任意元素周围的八个元素（下图中一个N代表一个邻居）：

```text
NNN
N N
NNN
```

这些邻居可以扩展到其社会的另一侧。例如，位于首行中的个体可能拥有三个位于最后一行中的邻居。当`T`的值从1增长到5的过程中，该游戏将会以下图所示的模式演变，在该图中，`T`的初始值为1，O代表活着的个体，空白符表示该处不存在活着的个体。

![图13-3](img/13-3.png)

其他社会可能会像下面这样稳定下来：

![图13-4](img/13-4.png)

你可以像下面这样用一个测试驱动器来查看该社区前五个版本的情况。当然，这需要用你在自己文件中设计的`GameOfLife`类构造函数来读取它的参数。

```C++
#include "GameOfLife.h" // For the GameOfLife class

int main() {
    GameOfLife society("5by7");
    for (int updates = 1; updates <= 5; updates++) {
        society.toString();
        society.update();
    }
    return 0;
}
```

除此之外，你还需要实现以下头文件中定义的成员函数：

```C++
/*
 *  File name: GameOfLife.h
 *
 * A model for John Conway's Game of Life to simulate the birth and death
 * of cells. This is an example of cellular automata.
 */

#ifndef GAMEOFLIFE_H_
#define GAMEOFLIFE_H_

#include <vector>
#include <string>

class GameOfLife {
    private:
        std::vector<std::vector<bool> > theSociety;
        int nRows;
        int nCols;

    public:
        /*
        * Write the constructor to initialize a vector of vectors so
        * all elements are false. Also set nRows and nCols
        *
        */
        GameOfLife(int rows, int cols);

        /*
         * Return the number of rows, which is indexed from 0..numberOfRows()-1.
         */
        int numberOfRows();

        /*
         * The number of columns, which is indexed from 0..numberOfColumns()-1.
         */
        int numberOfColumns();

        /*
         * Place a new cell in the society.
         * Precondition: row and col are in range.
         * row The row to grow the cell.
         * col The column to grow the cell.
         */
        void growCellAt(int row, int col);

        /*
         * Return true if there is a cell at the given row and column.
         * Return false if there is none at the speci ed location.
         *
         * row The row to check.
         * col The column to check.
         */
        bool cellAt(int row, int col);

        /*
         * Return one big string of cells to represent the current state of the
         * society of cells (see output below where '.' represents an empty space
         * and 'O' is a live cell. There is no need to test toString. Simply use
         * it to visually inspect. Here is one sample output from toString:
         *
         * GameOfLife society(4, 14);
         * society.growCellAt(1, 2);
         * society.growCellAt(2, 3);
         * society.growCellAt(3, 4);
         *  cout << society.toString();
         *
         * Output
         * ..............
         * ..O...........
         * ...O..........
         * ....O.........
         * */
        std::string toString();

        /*
         * Count the neighbors around the given location. Use wraparound. A cell
         * in row 0 has neighbors in the last row if a cell is in the same column
         * or the column to the left or right. In this example, cell 0,5 has two
         * neighbors in the last row, cell 2,8 has four neighbors, cell 2,0 has
         * four neighbors, cell 1,0 has three neighbors. Cell 3,8 has 3 neighbors.
         * The potential location for a cell at 4,8 would have 3 neighbors.
         *
         * .....O..O
         * O........
         * O.......O
         * O.......O
         * ....O.O..
         *
         * The return values should always be in the range of 0 through 8.
         */
        int neighborCount(int row, int col);

        /*
         * Update the state to represent the next society.
         * Typically, some cells will die off while others are born.
         */
        void update();
};

#endif /* GAMEOFLIFE_H_ */
```

由于`GameOfLife`这个游戏中存在着环绕现象。所以我们建议使用嵌套`for`循环来访问目标的那八个邻居。另外再用两个`int`变量来设置个体实际所在的行和列。如果检查到其邻居的索引值为负或超过了最大值，请将该个体社区想象成一个表面被个体覆盖的圆环，就像下面这样：

![图13-5](img/13-5.png)

在下图中，O的八个邻居被分别贴上了从a到h的标签。上述环绕现象影响的就是标签从d到h的那些邻居。这些标签的重复说明了它们需要执行的位置检查。

![图13-6](img/13-6.png)

*另一个提示：* 在执行更新操作的过程中，你可以设置一个所有元素都被设置成`false`的临时`vector`对象（当然是存储`vector`的`vector`）。然后用这个`vector`来观察变化，只增加这个临时`vecto人`中的个体。在更新完成后，再将该它赋值给原来的实例，像下面这样：

```C++
theSociety = temporary;
```

接下来，我们来示范两个针对不同个体社区的更新操作。在执行了21次更新后，右侧的社区较原来向右移动了五个空格。如果执行63次更新，你将会看到这个格式由于环绕的关系，由右侧移动到了左侧。

```text
(译者to编辑：
    此处排版太复杂，请引用原书中的代码，以下是其中的翻译：
    output：程序输出
    note：the sixth update shows wraparound：请注意：在执行60次更新之后出现环绕现象。
)

```