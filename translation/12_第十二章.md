# 第12章 指针与内存管理

## 前章回顾

到目前为止，我们存储对象所需的内存都是由交由系统后台自行分配的，访问内存也只能通过变量名或发消息的方式来完成。

## 本章提要

在本章，我们要来介绍一下“*间接（indirection）*”这个概念。间接的情况通常出现在某件事物出现替代品的时候。譬如，以图书目录卡为例，这种卡片上记录的是每本书的杜威十进制数，这些数字本身并不是书，它们只是对书的引用。由于该卡片从某种意义上来是命名了一些书所在的位置，所以这些信息也可以被视为是一种“地址”。在C++中，我们会用*指针（pointers）*来实现这种间接性、指针是一种用于存储其他变量地址（或指向它们的指针）的变量。出资为，本章还会介绍一下基于原生的C数组和内存管理。我们希望在学习完本章内容之后，你将能够：

* 理解指针这张用于存储其他对象地址的对象。
* 使用无边界检查的原生C++数组。
* 使用若干种方法来初始化指针。
* 使用`new`和`delete`这两种操作符来管理内存。

## 12.1 内存因素考量

每个对象都会有一个名称，一个状态以及一组可执行的操作。每个对象也都由自己的*作用域*（即它们被人知道的范围）和*生命周期*（即该对象被构造到被认为已经不存在的这段时间）。这一切都始于它们的初始化，譬如：

```C++
int able = 123;
int baker = 987;
```

在一个对象被初始化后。它上述的大部分特征都已经被定义得很清楚了。但对象在内存中的位置（也就是它们的地址）就没有那么清楚了。到目前为止，我们都是依靠系统自己来管理这些地址的。但C++是允许程序员直接对这些地址进行操作的。

每个对象都会驻留在一个特定的内存位置中，占据一个或多个字节的计算机内存。而每个对象在内存中的位置通常都是用它所占用的第一个字节的地址来表示的。举个例子，假设下面的表格是一个机器层视图，我们从中可以看到变量`able`的存储地址是6300，`baker`的存储地址是6304。这些地址是被任意安排的，也可以是其他地址。另外在C++中，`int`通常会占用四个字节的内存（当然，这不是一定的）。

| 地址         | 类型        | 名称       | 状态值  |
|--------------|------------|-----------|--------|
| 6300         | int        | able      | 123    |
| 6304         | int        | baker     | 987    |

如你所见，名为`able`的对象占据的是6300、6301、6302和6303这四个这季节的内存，它的地址是这四个字节中第一个字节的内存位置，即6300。尽管我们并不需要总是去了解对象的确切地址，但在基于C++来学习计算基础的过程中，对象的存储地址是一个很重要的概念。

许多对象的内存分配是在编译时完成的。通常情况下，`char`对象会被分配一个字节，`int`对象是两个字节还是四个字节要其取决于具体的计算机系统，`double`对象也需要有一个特定的、（至少对于机器而言）可预测的字节数。这些类型都被称之为 *静态（static）* 的，因为它们的内存分配都是在编译时完成的。静态变量被分配的内存量是固定的，程序在运行时无法对其进行修改。

指针对象可以让程序员们通过编写代码的方式在运行时分配内存。只要程序还在运行，它所获得的空间就是可用的。在运行时被分配的对象被称之为 *动态（dynamic）* 对象，因为它们都是在运行时获取内存块的。这种对象的主要优点是实现了内存的按需分配，其分配到的内存可在不被需要时撤销并归还给系统，以备后续使用。

动态对象可通过缩小或放大的方式来管理容器，这样以来容器的大小就只取决于可用的内存了。这可以让程序员们更有效地管理计算机资源。举个例子，`string`对象在后台采用的就是动态的内存分配，因此它可以在运行时调整自身的大小。毕竟使用这个`string`类的产品通常是无法预知其用户会在运行时输入多少字符的：

```C++
string name; // Memory allocated during input
cout << "Enter your name: ";
cin >> name;
```

`string`类也允许程序员们给其对象赋值行各种长度的字符串：

```C++
string a, b; // Appropriate memory is allocated on assignment

a = "The string a should have its own space"; // 38 chars 
b = "The string b should also"; // 24 chars
```

当然，我们也可以选择在构造`string`对象的过程中分配一个字符类型的`vector`，但将它设置得多大呢？我们当然可以为其设置一个足够大的尺寸，以便它可以应对大多数字符串。但这样做肯定会造成内存的大量浪费。想像一下，有一个存储1000个`string`对象的`vector`，其中每个`string`对象都被分配了128或200个字节的内存，但这些`string`的平均长度最终只存储9个字符，这是何等的浪费。如果没有指针，程序员们就必须采用这种浪费计算机内存的方法。所以要想了解内存管理，我们就必须先了解指针。

### 12.1.1 指针

*指针（Pointers）* 中存储的是其他对象的地址，作用是“指向”这些对象。声明指针对象需要在相应的类名之后加上一个星号（`*`)：

**通用格式 12.1**： *声明指针变量*

```text
class-name* identier;
```

这里的星号表示`identier`是一个用于存储`class-name`类型对象的地址的变量。例如，在下面这个声明中：

```C++
int* intPtr;
```

名为`intPtr`的指针对象中存储的是一个`int`对象的地址。换而言之，这个叫`intPtr`的对象本身并不代表一个`int`对象，它代表的是`int`对象的地址。通常情况下，一个指针对象的状态不外乎以下三种可能，三者必有其一：

1. 未定义状态（这表示`intPtr`当前存储的是垃圾信息）。
2. 等于一个叫做`nullptr`的特殊指针值，这时代表该指针不指向任何东西。
3. 指向了其声明类型的一个实体。

目前，任何试图对未定义状态`intPtr`值执行的操作都会导致未定义的系统行为。所以，常见的做法是将`intPtr`的值设置成一个特殊的指针常量`nullptr`，以表示该指针目前不指向任何东西。

```C++
intPtr = nullptr; // intPtr points to nothing
```

由于指针对象存储的是地址，我们将它表示成一个带箭头的盒子，让它指向相应的对象会更直观一些。所以对于下面的语句：

```C++
int anInt = 123; // Allocate memory for an int and initialize it
int* p; // Allocate memory to store the address of an int object
```

我们可以用下面这个图来表示：

![图12-1](img/12-1.png)

这里的`?`代表这个指针尚未被赋值。也就是说，`?`代表的是一个垃圾值。为了表示该指针现在不指向任何东西，我们在这里需要用到一个C++关键字，`nullptr`。

```C++
p = nullptr;
```

当指针`p`被赋予`nullptr`这个值时，`p`的状态可以用下面这个带对角线的图形符号来表示：

![图12-2](img/12-2.png)

指针对象可以通过`&`操作符来获取其要赋值的*地址*。`&`操作符返回的是其后面那个对象的地址。

**通用格式 12.2**： *获取某个对象的地址*

```text
&object-name;
```

举个例子，`&anInt`这个表达式得到的就是`anInt`的地址。我们可以通过下面的语句将`anInt`的地址存储到指针对象`p`中（在这里，我们可以将`&anInt`这个表达式读作”anInt的地址“）：

```C++
p = &anInt; // &anInt returns memory location (address) of anInt
```

这个赋值操作最好的图形化表示就是从之前的`？`处拉一个箭头指向`anInt`的地址所表示的内存。

![图12-3](img/12-3.png)

这个从`p`指向`anInt`的箭头代表`p`目前指向了`anInt`这个对象。但是，`p`中实际存储的是一个地址，也就是`anInt`在内存中的位置。

指针对象是可以间接改变其指向对象的状态的。例如，我们可以不通过`anInt`这个对象本身的名称来改变它的状态，这里需要用到叫做 *间接寻址（indirect addressing）* 的解引用操作。这种间接操作需要用`*`操作符来完成，它允许我们在程序中通过指针对象来检查或修改该指针指向的内存。下面我们就来示范一下如何通过`p`修改`anInt`所在的内存：

![图12-4](img/12-4.png)

**通用格式 12.3**： *间接寻址*

```text
*pointer-object;
```

也就是说，针对`*p`的赋值操作要修改的不是`p`本身，而是`p`所指向的对象的状态。

请注意，`*`操作符在指针方面有两种不同的含义。首先在声明语句中，它表示我们正在声明的是一个指针。例如：

```C++
int* pInteger;
double* pDouble;
```

其次，在当我们将星号与指针放在一起使用时，它代表的是对指针的解引用操作：

```C++
*pInteger = 456;
*pDoube = 123.45;
```

另外在数学方面，`*`还代表了乘法运算。如你所见，星号的确是个被重载的操作符。所以我们要根据它们在代码中的具体运用来确定星号所代表的意义。

总而言之，在指针对象之前加一个星号代表的是该指针指向的那个地址，并可以对那个地址中的值进行存储和修改。例如，如果`anInt`被存储在地址为6308的内存中，那么`p`中存储的值就是6308。

![图12-5](img/12-5.png)

为了说明`p`、`*p`和`&anInt`这三者之间的区别。我们打算用下面这段程序示范一下间接寻址的用法。这段程序的作用就是交换两个指针的值，在执行完该程序后`p1`和`p2`都应该指向彼此原本指向的`int`对象[^1]。

[^1]: 译者注：原文如此，但从上下文来看，似乎应该是`double`对象。

请注意，由于指针指向的是`double`类型的值，所以它们也必须被声明成`double`类型的指针。这样做是为了告诉编译器，它要转向的是一个存储在`double`指针中的地址，要以足够的字节数来对去这个`double`对象（通常是8个字节）。

```C++
// Interchange two pointer values. The pointers are switched
// to point to the other's original int object.
#include <iostream>
using namespace std;

int main() {
    double* p1;
    double* p2;
    double* temp;
    double n1 = 99.9;
    double n2 = 88.8;

    // Let p1 point to n1 and p2 point to n2
    p1 = &n1;
    p2 = &n2;

    cout << "*p1 and *p2 before switch" << endl;
    // Get the integers indirectly with the \* operator
    cout << (*p1) << " " << (*p2) << endl;

    // Swap the pointers by letting p1 point to where p2 is pointing.
    // Also let p2 point to where p1 is pointing.
    temp = p1;
    p1 = p2;
    p2 = temp;

    // Now the values of the pointers are switched to point to each
    // other's int object. The ints themselves do not move.
    cout << "*p1 and *p2 after switch" << endl;
    cout << (*p1) << " " << (*p2) << endl << endl;

    cout << "Actual memory locations in hexadecimal:" << endl;
    cout << p1 << " " << p2 << endl;

    return 0;
}
```

#### 程序输出

```text
*p1 and *p2 before switch
99.9     88.8
*p1 and *p2 after switch
88.8     99.9

Actual memory locations in hexadecimal:
0x7fff5d00cbf0 0x7fff5d00cbf8
```

在该程序中，99.9和88.8这两个字在内存中并没有被移动过。我们只是将指向这些`double`对象的指针进行了互换。下面我们用图形化的方式来跟踪一下这个程序的执行过程。首先是所有五个对象的初始化工作（*请注意：* 下面所有盒子都代表着一块存储某个对象状态的内存）：

![图12-6](img/12-6.png)

在接下来的两条语句（即`p1 = &n1; and p2 = &n2;`），我们将两个`double`对象的地址存储到了相应的指针中。然后是`temp = p1;`这条语句，它让指针对象`temp`也指向了`p1`所指向的那块内存。

![图12-7](img/12-7.png) [^2]

[^2]: 译者注：该图中的注释似乎与实际情况不符，这是一个double对象，而不是一个integer对象。

也就是说，`p1`中的地址（我们用箭头来表示）也被存储到了`temp`中，这时候表达式`temp == p1`应为`true`。这样做所产生的变化就是让`p1`和`temp`的箭头都指向了相同的位置，就是那个名为`n1`的对象。

再接下来，我们执行的是`p1 = p2;`这个赋值动作，它让`p1`与`p2`指向了相同的地方。所以现在`p1`和`p2`存储的是相同的地址，这两个指针的值是相等的。

![图12-8](img/12-8.png)

然后是最后一条语句`p2 = temp;`，它让`p2`指向了`p1`原本指向的那个`double`对象。

![图12-9](img/12-9.png)

现在，`p2`指向了`n1`，`p1`指向了`n2`。换句话说，如果现在执行`cout << (*p1)`这个操作输出的是88.8，而不是原来的99.9了。

我们首先要明白的是，指针的使用并不容易。这需要我们将理解的对象概念从存储值的对象切换成存储其他对象地址的对象。因为在使用指针时，我们要做的算法设计和程序调试是不一样的。在调试过程中，用箭头来表示指针的值是一个不错的低成本辅助工具，我们可以通过移动箭头而不是填写地址的方式来跟踪算法。

另外在编写调试代码时，被指向的值通常要比该对象所在的地址更有价值。所以我们在调试时应该多使用带`*`操作符的`cout << (*aPointer);`语句，而不是`cout << aPointer;`。这样我们才能看到更有价值的对象值，而不是这些对象的地址。

### 12.1.2 指向对象

之前，我们所讨论的指向`int`和`double`对象，实际上都是在引用这些位置上存储的单值。它们并没有关联的成员函数。现在我们要来关注一下用指针向其指向的对象发送消息的过程中会发生什么情况。首先，由于解引用操作符的优先级低于函数调用操作的，所以像下面这样是不行的：

```C++
BankAccount anAcct("Functions > Dereference", 123.45);
BankAccount* bp;
bp = &anAcct;
*bp.deposit(123.45); // ERROR
```

解决该问题的方法之一就是将解引用操作放在一个括号，以覆盖掉其原本的优先级。这样`*bp`就能在调用之`deposit`函数*之前*返回一个`BankAccount`对象了：

```C++
(*bp).deposit(123.45); // OKAY
```

或者我们也可以使用C++提供的箭头操作符`->`来简化指针指向相关类示例的方式：

```C++>
bp->deposit(123.45); // SHORTCUT
```

下面我们在一段程序中实际使用一下这两种技术：

```C++
#include <iostream>
using namespace std;
#include "BankAccount.h"

int main() {
    BankAccount anAcct("both (*bp) and bp-> work ", 100.00);
    BankAccount* bp;
    bp = &anAcct;

    // Wrap the dereference in parentheses because the dereference
    // operator * has lower precedence than function calls

    (*bp).deposit(123.45);
    cout << (*bp).getName() << (*bp).getBalance() << endl;

    // Use -> for pointers to objects other than int or double
    bp->withdraw(111.11);
    cout << bp->getName() << bp->getBalance() << endl;

    return 0;
}
```

#### 程序输出

```text
both (*bp) and bp-> work 223.45
both (*bp) and bp-> work 112.34
```

### 自检题

* 12-1. 指针对象中存储的是什么？

* 12-2. 请根据下面的语句回答下列问题：
    ```C++
    double* doublePtr;
    double aDouble = 1.23;
    doublePtr = &aDouble;
    ```
  * a.  指针对象的名称是什么？
  * b.  `doublePtr`的值是什么？
  * c.  `*doublePtr`的值是什么？
  * d.  请编写代码，*间接地*将`aDouble`的值从1.23改成2.23。

* 12-3. 请问在下面这段代码执行之后，`*ptr`的值是什么？
    ```C++
    int anInt = 123;
    int* ptr = &anInt;
    *ptr += *ptr;
    ```

* 12-4. 请问在下面这段代码执行之后，`s3`的值是什么？
    ```C++
    string s1 = string("one");
    string* p1 = &s1;
    string s3 = p1->c_str();
    s3 += p1->c_str();
    cout << s3;
    ```

* 12-5. 请编写一个表达式，计算出下面两个`BankAccount`对象的余额之和。
    ```C++
    BankAccount ba1("one", 100.00);
    BankAccount ba2("two", 200.00);
    BankAccount* a = &ba1;
    BankAccount* b = &ba2;

* 12-6. 请写出下面程序会产生的输出：
    ```C++
    #include <iostream>
    using namespace std;
    int main() {
        int* p;
        int j = 12;
        p = &j;
        cout << ((*p) + (*p)) << " " << ((*p) * (*p)) << endl;
        return 0;
    }
    ```

* 12-7. 请编写一条语句，将一个`char`对象`ch`的地址存储到一个名为`charPtr`的指针对象中。

* 12-8. 请以最小的代码量声明并初始化下图中所有的对象：

    ![图12-10](img/12-10.png)

* 12-9. 请根据你在回答上一个问题时编写的代码写一条语句，使用`*`解引用操作符间接地输出所有整数的和值。

* 12-10. 请写出下面程序会产生的输出：
    ```C++
    int p = 111;
    int* q = &p;
    p += 222;
    cout << "p? " << p << endl;
    cout << "q? " << *q << endl;
    ```

* 12-11. 请写出下面程序会产生的输出：
    ```C++
    int n1 = 4;
    int n2 = 8;
    int* ptr1;
    int* ptr2;
    ptr1 = &n1;
    ptr2 = &n2;
    cout << (*ptr1) << " " << (*ptr2) << endl;
    ```

* 12-12. 请写出下面程序会产生的输出：
    ```C++
    double* p = new double;
    double* q = new double;
    *p = 1.23;
    *q = 4.56;
    p = q;
    cout << (*p) << " " << (*q);
    ```

* 12-13. 在之前12-12题的代码中，我们能否通过修改最后一行代码检索出1.23这个值？

***

## 12.2 原生的C数组

The vector class is a relatively new addition to C++. In the past, the built-in, primitive C array was frequently used to store collections of objects. Because an array actually stores the address of the first element, it is a useful example for illustrating pointer usage. The C array is used so frequently for implementing programs that you are likely to see it in existing code. But more importantly, the primitive C array illustrates the benefits of dynamic memory management. It provides a peek under the hood of vector::resize and string assignments. Both use pointers and dynamic allocation to better manage memory.

The primitive C array is a fi xed-size collection of elements that are of the same class. Arrays are homogeneous because they store collections of like objects. The objects in the collection may be one of the built-in classes char, int, long, or double. The objects may also be declared as a programmer-defined class such as BankAccount as long as the class has a default constructor.

Here is the general form for declaring a primitive C array:

**General Form 12.4** *Array declaration*

```text
type array-name[capacity];
```

The *type* specifies the type of objects stored under *array-name*. The *capacity* specifies the maximum number of elements that can be stored under the array name. Th e capacity must be an integer constant (such as 100) or a named integer constant. An array cannot be sized or resized at runtime as a vector object can, at least not as a standard operation. Th e array shown next stores a maximum of one hundred:

```C++
double x[100];
```

Individual array elements are referenced through subscripts in the same manner seen with vector objects:

**General Form 12.5** *Referencing individual array elements*

```text
array-name[int-expression];
```

The subscript range of a primitive array is the same as a vector going from 0 through capacity - 1.

### 12.2.1 DIFFERENCES BETWEEN PRIMITIVE ARRAYS AND vectors

There are many similarities between arrays and vectors—especially in the referencing of individual elements. In fact, the same vector-processing algorithms of chapter 10, “Vectors,” could also be applied to primitive C arrays. The most noticeable difference is that primitive C arrays cannot be made to automatically check for out-of-bounds subscripts. Th is is one of the drawbacks of the C array. It is safer to have the subscript range-checking feature available, especially when first learning about arrays and vectors.

Some very strange errors occur when the code lets the computer “walk off ” the end of an array. The important state of other objects may be accidentally destroyed. With the subscript range checking of vector objects, the program can notify the programmer whenever there is an attempt to reference out-of-bounds memory. This can be a preferable situation.

Here are the diff erences between the vector class and primitive C arrays:

| Difference | vector Example | C Array Example |
|------------|----------------|-----------------|
| vectors can initialize all vector elements at construction; arrays cannot. | vector <int> x(100, 0); // All elements are 0 | int x[100]; // Elements are garbage |
| vectors can be easily resized at runtime; arrays take a lot more work. | int n; cin >> n; x.resize(n); | // See growing an array // in a later chapter
| vectors can be made to prevent out-of-range subscripts.| // You are told // something is wrong cin >> x.at(100); | // Destroys other variables cin >> x[100]; |
| vectors require an #include; primitive, built-in arrays do not. | #include <vector>  | // No #include required |

### 12.2.2 THE ARRAY / POINTER CONNECTION

It turns out that all primitive C array variables actually store the pointer to—or the address of— the first array element. Whenever the subscript operator is applied to an array object, an address is computed. For example, if x is an array of integers, each array element is four bytes long, and x has the value of address 6000, the following formula computes x[3] as 6000 + (3 * 4).

**Formula for Computing the Address of Individual Array Elements**

```text
address of first array element + (subscript * size of one element)
```

Therefore, x[3] is stored at address 6012.

| Reference | Address | Value |
|-----------|---------|-------|
| x[0]      |  6000   | ?     |
| x[1]      |  6004   | ?     |
| x[2]      |  6008   | ?     |
| x[3]      |  6012   | ?     |
| x[4]      |  6016   | ?     |

### 12.2.3 PASSING PRIMITIVE ARRAY ARGUMENTS

When an array is passed to a function, the address of the first array element gets sent. Arrays are automatically passed by reference. An array parameter is declared with the class and the parameter name followed by [ ]. Th is is illustrated in the next program where main() passes an array to the function init. Notice that when the function init alters the array parameter x, the associated array argument anArray is also altered. Both x and anArray have the first three array elements assigned a value (90, 95, 99). This occurs even though & is not used for the parameter anArray. anArray is passed by value.

```C++
// Pass the address of the array to a function.
// The & is not required. An array stores an address.
#include <iostream>
using namespace std;

void init(int x[], int & n) {
    // x and n are reference parameters; however, x does not need &
    x[0] = 90;
    x[1] = 95;
    x[2] = 99;
    n = 3;
}

int main() {
    int n = 5;
    int anArray[5];

    init(anArray, n); // init will change x and anArray for (int index = 0; index < n; index++) {
        cout << anArray\[index\] << " ";
    }
    cout << endl;

    return 0;
}
```

#### Output

```text
90 95 99
```

Since the value stored in the array name is an address—a reference to the first array element, passing the array name to a function actually passes an address. Therefore, arrays are automatically passed by reference, which is the address of the fi rst array element. Subscripting parameter x results in the equivalent of subscripting argument anArray. Th e following figure depicts that anArray was passed by reference, even though & was not used:

![图12-11](img/12-11.png)

## 12.3 ALLOCATING MEMORY WITH new

Pointer objects are frequently assigned values through the new operator. When the new operator precedes a class name, the resulting expression allocates a contiguous block of memory large enough to store one instance of that class. Additionally, the same expression returns the address, or a pointer to, this memory.

**General Form 12.6** *Dynamic memory allocation (for one object only)*

```C++
new class-name
```

The memory is allocated at runtime from the *free store*—a portion of computer memory reserved for this purpose (the free store is sometimes called the *heap*). For example, the following expression allocates enough memory to store one int value. The expression returns a pointer to that memory.

```C++
new int; // Allocate memory, return a pointer value (an address)
``` 

Instead of ignoring the returned pointer value (the address where an integer could be stored), such pointer expressions are usually combined with pointer objects in initializations.

```C++
int* intPtr = new int; // Allocate memory, store address in intPtr
```

The above is an abbreviated form of the following equivalent code:

```C++
int* intPtr;
intPtr = new int; // Allocate memory, store address in intPtr
```

Now we have a situation where intPtr holds the address of an int object—where an int could be stored. This is shown in the next figure where the undefi ned int value is signifi ed as ? and the pointer value is represented as an arrow indicating a value that points to that undefi ned int:

![图12-12](img/12-12.png)

This statement initializes that new allocation of memory:

```C++
*intPtr = 123;
```

This resulting representation shows the state of the pointer and the int:

![图12-13](img/12-13.png)

The following program shows dynamic allocation of one int object:

```C++
// Illustrate one pointer object and one int object
#include <iostream>
using namespace std;

int main() {
    // Declare an intPtr as a pointer to an int
    int* intPtr;

    // Allocate memory for an int and store address in intPtr
    intPtr = new int;

    // Store 123 into memory referenced by intPtr
    *intPtr = 123;

    cout << "\n The address stored in the pointer object: " << intPtr;
    cout << "\nThe value of the int pointed to by intPtr: " << \*intPtr;

    return 0;
}
```

#### Output (address shown in hexadecimal (a is 10, f is 15)

```text
The address stored in the pointer object: 0x7fbd3bc04a20
The value of the int pointed to by intPtr: 123
```

Notice that the pointer object, with value 25,360 (0x7fbd3bc04a20 hexadecimal), is referenced as intPtr. Th e actual int with value 123 is dereferenced as *intPtr.

### 12.3.1 ALLOCATING MEMORY FOR ARRAYS AT RUNTIME

At times it is convenient to allocate arrays at runtime, when a maximum capacity is better known. The C++ new operator accomplishes this by allocating memory for many objects with [*capacity*], where *capacity* represents the number of objects to allocate.

**General Form 12.7** *Dynamic memory allocation (capacity objects)*

```C++
new type[capacity];
```

*Example:* allocate memory for 10 integers

```C++
new int[10]; // Allocate memory for 10 integers and return              // a pointer to this newly allocated memory
```

Because new returns a pointer to the first byte of the array, it can be used for pointer object initialization with this shortcut:

**General Form 12.8** *Initializing pointer objects*

```C++
type* identier = new class-name[number of elements];
```

*Example:*

```C++
int* nums = new int[10];
```

Now the pointer object nums points to the fi rst of 4 \* 10 bytes of uninitialized (garbage) memory where each 4 bytes stores one integer:

![图12-14](img/12-14.png)

One time you might find this dynamic allocation of memory useful is when you have an array of objects set to an initial capacity, and then at runtime, you need to store more than the maximum capacity. This can be done with the following algorithm:

- Make a temporary array that is bigger than the instance variable.
- Copy the original contents (num[0] through nums[n - 1]) into this temporary array.
-  Assign the reference to the temporary array to refer to the original array.

```C++
// This code dynamically (at runtime) "grows" an array
#include <iostream>
using namespace std;

int main() {
    int n = 10;
    int* nums = new int[n]; // Some C++ compilers can not handle int[n]
    int anInt = 1;
    // Initialize n array elements with a for loop
    for (int i = 0; i < n; i++) {
        nums[i] = anInt;
        anInt += 3;
    }

    // Show the lled array
    for (int i = 0; i < n; i++) {
        cout << nums\[i\] << " ";
    }

    // Need more room? Grow the array at runtime
    int* temp = new int[n+5]; // Some C++ compilers can not handle int[n+5]
    // 2) copy the elements to the temporary array
    for (int i = 0; i < n; i++) {
        temp[i] = nums[i];
    }

    // Make the original array pointer refer to the "bigger" array
    nums = temp;

    // Add 3 more elements to the bigger array
    nums[n++] = 997;
    nums[n++] = 998;
    nums[n++] = 999;

    // Print the larger array with the added elements
    cout << endl << "Larger array" << endl;
    for (int i = 0; i < n; i++) {
        cout << nums\[i\] << " ";
    }

    return 0;
}
```

#### Output

```text
 1 4 7 10 13 16 19 22 25 28
 Larger array
 1 4 7 10 13 16 19 22 25 28 997 998 999
```

Here are the arrays through pictures—fi rst the original array filled to capacity:

![图12-15](img/12-15.png)

This is the new array with twice the capacity of the original:

![图12-16](img/12-16.png)

Finally, nums is made to point to the new array, the same one referenced by temp with this one assignment statement:

```C++
nums = temp;
```

After three integers are added to the larger-capacity array, we have this situation:

![图12-17](img/12-17.png)

### SELF-CHECK

- 12-14 Write the output of the following code:
    ```C++
    int* x = new int[10];
    x[0] = 4;
    x[1] = 8;
    cout << x[0] + x[1] << endl;
    ```

- 12-15 Write one initialization using new to allocate an array that can store 1000 doubles.

- 12-16 Write the code that initializes all 1000 doubles of the previous question to -1.

- 12-17 Write the output generated by the following code:
    ```C++
    const int MAX = 6;
    int* x = new int[MAX];

    for(int i = 0; i < MAX; i++) {
        x[i] = 2 * i;
    }

    for(int i = 0; i < MAX; i++) {
        cout << x[i] << " ";
    }
    ```

- 12-18 Primitive arrays can be declared and initialized at the same time with array initializers such as the following:
    ```C++
    int x[] = {3, -4, -3, 6, 1};
    int n = 5;
    ```
  Write the code that finds the range of the array elements in x. Range is defined as the largest minus the smallest integer. Your code must work for arrays that have array initializers with diff erent values and capacities.

- 12-19 Declare an array of strings with an array initializer that has the following strings in this order: "a", "b", "c", and "d".

***

## 12.4 THE delete OPERATOR

So far, the new operator examples allocated only small amounts of memory. However, consider what happens when dynamic data grows to a large size. Using new without returning memory to the free store results in a *memory leak*. This limits the amount of memory available to a program.

At some point, a program no longer needs dynamically allocated memory. When this occurs, the unneeded memory should be allocated back to the free store. This makes it available for other objects that have yet to be dynamically allocated. This return of memory, or *deallocation*, is accomplished with the C++ built-in *delete* operator. The delete operator has two general forms:

**General Form 12.9** *Deallocating memory—a form of recycling*

```C++
delete pointer-object;
delete[] pointer-to-array;
```

The first form returns the memory allocated for one dynamic object back to the free store. Th e second form returns memory allocated for a group of objects with new and [ ]. In the following program, the delete operator allocates enough memory for one double pointed to by p, ten chars pointed to by charArray, and 100 integers pointed to by x.

```C++
// Allocate and deallocate memory at runtime
#include <iostream>
using namespace std;

int main() {
    int* p = new int; 
    *p = 123;

    int* x = new int[10000]; // claim 40,000 bytes from the free store
    x[0] = 76;
    x[1] = 89;
    // ...
    x[9999] = *p;

    // When no longer needed, free the memory to avoid memory leaks 
    delete p;
    delete[] x;
    // All the bytes of memory pointed to by p and x can be allocated later

    return 0;
}
```

After the two delete statements return the allocated memory back to the free store, the pointers should not be used. Using them at this point results in unpredictable behavior. 

Our programs with arrays should use delete to return the memory no longer needed. There are no notifications or errors shown. Instead, we get memory leaks, which means memory no longer needed cannot be recycled later.

```C++
double* temp = new double[n+5];
for (int i = 0; i < 10; i++) {
    temp[i] = nums[i];
}

delete[] nums; // Avoid a memory leak by freeing up memory
```

## 12.5 THE SINGLY LINKED STRUCTURE WITH C structs

A singly linked data structure is an alternative way to store a collection of elements in a sequential fashion. Th ere is high probability that your standard C++ list class has been implemented using a linked structure with some of the concepts presented in this section.

Instead of having elements stored in contiguous memory, this singly linked structure will have a collection of linked node objects where each node stores an element and a link to the next node in the sequential collection. We also need a pointer to the first node, which is named first here.

To accomplish this, a pointer data member is added to a class or a struct. A struct is the same thing as a class except that by default, members of a class are private and members of a struct are public. However, if you use public and private explicitly, there is no difference other than the name. Th e struct is presented here for historical reasons and because structs typically have constructors and data members only. Because struct data members are public by default, adding public: is not necessary.

![图12-18](img/12-18.png)

An example struct with two public data members and a start to
LinkedList:

```C++
#ifndef LINKEDLIST_H_
#define LINKEDLIST_H_

/**
  * This le contains two types:
  *
  * 1) struct node to hold an element and a link to
  *    another node
  * 2) class LinkedList to hold an indexed sequential 
  *    collection using the singly linked data structure
  *
  * A LinkedList can only store string elements. Templates 
  * are not used here to allow focus on pointers and 
  * memory management.
  */

struct node {
    // Two public data members
    std::string data;
    node* next;

    // Two public constructors
    node() {
        next = nullptr;
    }

    node(std::string element) {
        data = element;
        next = nullptr;
    }
};
// class LinkedList will go here . . .

#endif /* LINKEDLIST_H_ */
```

The following code constructs a new node object pointed to by first and displays the value using the -> operator, which is necessary for dereferencing the public data members of node.

```C++
#include <iostream>
#include <string>
#include "LinkedList.h"
using namespace std;

int main() {
    // Let nodePointer reference a dynamically allocated node object
    node* first = new node("Kim");
    // assert: nodePointer->next == nullptr

    // Display the state of the public data member my_data 
    cout << " The value: " << first->data << endl;
    cout << "#characters: " << rst->data.length() << endl;
}
```

#### Output:

```text
The value: Kim
#characters: 3
```

Here is a representation of what this looks like in memory:

![图12-19](img/12-19.png)

A linked structure has the characteristic that one element can be referenced from another element. With a data member to store a pointer to another object of the same class, objects can be linked together in such a way that the pointer in the first node object can be used to find the second node. The following code constructs three node objects that are linked together. Notice that a reference to the data of the second node is made using the pointer p >next.

```C++
// Build the first node
node* p = new node("One");

// Construct a second node pointed to by the first node's next
p->next = new node("Two");

// Build a third node pointed to by p->next->next
p->next->next = new node("Three");
```

Here is a representation of what three linked nodes look like in memory:

![图12-20](img/12-20.png)

These three nodes can be traversed by allowing a pointer, named ptr here, to refer to all three nodes. It begins by having ptr point to the first node. If ptr is not nullptr, the node’s data is displayed (inside the loop).

```C++
// Traverse the nodes until a next eld is nullptr
node* ptr = p; // Don't change p, which is a pointer to the first node
while(ptr != nullptr) {
    cout << ptr->data << endl;
    ptr = ptr->next;
}
```

ptr is updated to point to the next node or it is set to nullptr at the end of each loop iteration with the statement ptr = ptr >next.

### 12.5.1 A LIST CLASS USING THE SINGLY-LINKED DATA STRUCTURE

This section describes LinkedList member functions that use these node objects. The constructor establishes an empty list using a dummy header node. Th is makes the coding easier during add and remove.

```C++
class LinkedList {

    private:
        node* header;
        node* last;
        int n;
    public:
    //--constructor
        LinkedList() {
            // Create a dummy header node to make things easier
            header = new node; // call node's default constructor
            last = first;
            n = 0;
        }
```

Here is a representation of what an empty list with a dummy first node looks like in memory:

![图12-21](img/12-21.png)

### 12.5.2 add(std::string)

Adding an element to a linked list has diff erent meanings for ordered and unordered lists. An ordered list stores objects in an ascending order based on the meaning of <. The linked list developed here is not ordered so the elements will not be in alphabetic order. Since this linked list here is unordered, all new elements can be added at the very end of the list. Th is is easy when a dummy headed node is employed to avoid the special case of adding to an empty list or removing an element. Elements are added by creating a new object pointed to by last->next. Th e member data last must then be updated to point to the last node. The current count must also be incremented.

```C++
void add(const std::string newElement) {
    // Allocate and initialize a new node
    last->next = new node(newElement);

    // Update the last pointer
    last = last->next;

    // Maintain current size
    n++;
}
```

This one adds message results in the pictures of memory shown below:

```C++
LinkedList stringList;   // n == 0
stringList.add("First"); // n == 1
```

![图12-22](img/12-22.png)

```C++
stringList.add("Second"); // n == 2
stringList.add("Third"); // n == 3
```

![图12-23](img/12-23.png)

### 12.5.3 get(int index)

The get operation uses a for loop to advance an external pointer ptr to the correct node. Notice that if index is 0, the for loop does not advance ptr, leaving it to point to the first real node— the one pointed to by header->next, which would be the value "first".

```C++
std::string get(int index) {
    node* ptr = first->next;
    for (int i = 0; i < index; i++) {
        ptr = ptr->next;
    }
    return ptr->data;
}
```

### 12.5.4 remove(string removalCandidate)

These two possibilities must be considered when removing an element from a linked list:

1. the == operation does not match an element in the list
2. the == operation does match an element in the list

The search for a particular element in a linked list is similar to a sequential search through a vector or array. The difference is that now, instead of a subscript, a pointer will be used to access the data members.

The search for "Second" begins by pointing a variable named ptr to the first element in the list. With the node header, we can peek one node ahead in the search while maintaining a pointer to the node that precedes the node to be removed.

![图12-24](img/12-24.png)

A sequential search continues until ptr->next->data equals the removalCandidate or there are no more elements to search. Since ptr->data == removalElement ("First" == "Second") is false, the loop advances ptr to the next node in the list.

![图12-25](img/12-25.png)

Now the node pointed to by ptr points to the node before the node to be removed: ptr->next->data == "Second" is true now. With the help of the dummy header node, this algorithm is able to peek at the data one node ahead. This comes in handy as we need to send a pointer around the node to be deleted with ptr->next = ptr->next->next.

![图12-26](img/12-26.png)

Now the node pointed to ptr->next can safely be returned to the free store with delete.

```C++
bool remove(const std::string removalElement) {
    // Create an external pointer to point to the node before the first node
    node* ptr = header;

    // Search the remaining list elements until
    // found or the end of the list is found
    while (ptr->next != nullptr && ptr->next->data != removalElement) {
        ptr = ptr->next;
    }

    // Don't delete a nonexistent node
    if (ptr->next == nullptr) {
        // removalElement was not found
        return false;
    } else {
        // Check if the last node is being removed so last gets corrected
        if(ptr->next == last) {
            last = ptr;
        }

        // Send the link around the node to be removed
        ptr->next = ptr->next->next;
        if (ptr != header)
            delete ptr->next;// Deallocate memory
        n--;                 // Maintain current size
        return true;         // Report successful removal
    }
}
```

If the last node is to be removed, last must be adjusted to the preceding node. If ptr points to the last node, the element was not found so remove returns false.

### SELF-CHECK

- 12-20 Draw a picture of a linked list with two nodes before and after removing the fi rst node.

- 12-21 Draw a picture of a linked list with one node before and after removing the fi rst node.

- 12-22 What happens if removalCandidate is not found in the list?

- 12-23 True or False
  - a.  The size of a dynamically linked list must be determined before the program begins to execute.
  - b.  Elements in a linked list are referenced through subscripts.
  - c.  Elements may be inserted into or deleted from a linked list at the beginning, end, or even the middle of a linked list.
  - d.  When an element is to be inserted into or deleted from a linked list, the list should be checked to see if it is empty.
  - e.  When an element has been removed from a dynamically linked list, the memory it used should be returned to the free store.

- 12-24 Write method bool removeLast() to remove the last element in a LinkedList. Return false if the list is empty. The program should generate the output shown in comments.
    ```C++
    #include <iostream>
    #include <string>
    #include "LinkedList.h"
    using namespace std;

    int main() {
        LinkedList list;
        cout << list.removeLast() << endl; // 0
        list.add("A");
        cout << list.removeLast() << endl; // 1
        list.add("B");
        list.add("C");
        list.add("D");
        cout << list.removeLast() << endl; // 1
        list.add("E");
        cout << list.get(0) << " ";
        cout << list.get(1) << " ";
        cout << list.get(2) << endl; // B C E
        cout << list.size() << endl; // 3
        return 0;
    }
    ```

***

## CHAPTER SUMMARY

- Pointers store addresses of other objects. A pointer object points to some object. For example, ptr is a pointer and *ptr is a reference to the double object x that starts as 99.9.
    ```C++
    double * ptr;
    double x = 99.9;
    ptr = &x;
    *ptr = 1.234;
    ```
  In the last statement, the pointer changes the value stored in x to 1.234. The * (asterisk) dereferences the pointer. This means the pointer goes to the address stored in the pointer, which in this case is the address of x and changes the value stored at that address. Therefore, the pointer changes the value stored in x indirectly.

- The address of a variable is the first address at the location where the state is stored. If it takes 4 bytes to store an int, the address of the int is the address of the first byte of the int value, which is the address stored in the pointer. The pointer knows when to stop reading addresses because the pointer was declared as an int pointer. Therefore, it reads 4 bytes (this may vary depending on your computer system).

- The address operator & gives us the address of a variable.

- The primitive C array—similar to the C++ vector class—is available on all compilers and will often be seen in existing C and C++ code.

- The new operator allocates memory from the free store. The delete operator deallocates memory. If more than one object is allocated as in char* name = new char[10]; it must be deallocated with [] like this: delete [] name;

- You can allocate memory at runtime with new and return it to the free store with delete.

## PROGRAMMING TIPS

1. Draw linked structures when debugging programs with pointers. The value of a pointer object represents a location in the memory of the computer. Th ese values are difficult to use in a program trace. A diagram with arrows and boxes makes execution simulation and pointer debugging much clearer.

2. Pointers allow dynamic allocation of arrays. One problem when using arrays involves how big to make them at compile time. It may be big enough one time, but not another. Sometimes memory gets wasted when declared too big.

3. Use vectors instead of arrays. Th e standard vector type can be dynamically grown, or shrunk even, at runtime with resize messages. Let this well-tested class do the work for you.

4. Avoid memory leaks. Use the delete operator to return the memory back to the free store for single variables. Use the delete[] operator to free an array of values.

## EXERCISES

1. Write the values of the attributes supplied by this initialization:
    ```C++
    double x = 987.65;
    ``` 

    * a. class
    * b. name
    * c. state
    * d. address

2. Declare a pointer to an int and initialize the pointer somehow.

3. Use these statements to answer the questions that follow:
    ```C++
    int* intPtr;
    int anInt = 123;
    intPtr = &anInt;
    ```

    * a.  What is the name of the pointer object?
    * b.  What is the value of *intPtr?
    * c.  Without using anInt, write a statement that adds 100 to the memory storing 123.

4. Write the minimum declarations and statements that declare and initialize all the objects as they are shown in the diagram below.

    ![图12-27](img/12-27.png)

5. Using your code from the previous question, write the statements that will have a pointer object named largestPtr pointing to the largest integer no matter where it is stored among a, b, and c.

6. Using the declarations shown, which of the following are valid assignments that do not generate an error?
    ```C++
    int j = 456;
    int* p;
    ```

    * a. p = j
    * b. p = &j
    * c. p = 0
    * d. j = p
    * e. j = 123
    * f. *p = j
    * g. p = &p
    * h. p = 123
    * i. *p = "abc"
    * j. *j = 123
    * k. j = &p
    * l. *p = *p

7. Write the output generated by this code:
    ```C++
    int * intPtr;
    int anInt = 987;
    intPtr = &anInt;
    *intPtr = *intPtr + 111;
    cout << *intPtr << " " << anInt;
    ```

8. Trace the following program segment by drawing pictures of the modified objects:
    ```C++
    n1 = 123;
    p1 = &n1;
    *p1 = *p1 + 111;
    ```

9. Trace the following program segment by drawing pictures of the modified objects:
    ```C++
    n2 = 999;
    p3 = &n2;
    p2 = p3;
    ```

10. Trace the following program segment by drawing pictures of the modified objects:
    ```C++
    int * intPtr;
    intPtr = p3;
    ```

## PROGRAMMING PROJECTS

### 12A. ENHANCE LinkedList

Add two methods to the LinkedList class:

1. void toString() to return a string containing all elements with 10 elements separated by a new line “\n”.

2. void insertInOrder(std::string element) to insert string elements into the singly linked structure while maintaining alphabetical ordering.

### 12B. CLASS LinkedStack WITH A SINGLY LINKED STRUCTURE

Implement class LinkedStack which allows elements to be added and removed in a last-in, first-out (LIFO) manner. This class must use a singly-linked structure to store the elements.

Stacks have an operation called push to place elements at the “top” of the stack and another operation called pop to remove and return the element at the top of the stack. The only element on the stack that may be referenced is the one on the top. This means that if two elements are pushed onto the stack, the topmost element must be popped (removed) from the stack before the fi rst-pushed element can be referenced. Here is a stack program for storing strings:

```C++
#include <iostream>
#include <string> // Needed by Visual Studio
#include "LinkedStack.h"
using namespace std;

int main() {
    LinkedStack stack; // stack of 20 strings

    // Use intStack
    stack.push("a");
    stack.push("b");
    stack.push("c");
    stack.push("d");

    cout << "d? " << stack.peek() << endl;
    cout << "d? " << stack.pop() << endl;
    cout << "c? " << stack.peek() << endl;

    cout << "isEmpty 0? " << stack.isEmpty() << endl;
    cout << "c b a? ";
    while(! stack.isEmpty()) {
        cout << stack.pop() << " ";
    }
    cout << endl;
    cout << "isEmpty 1? " << stack.isEmpty() << endl;

    return 0;
}
```

Using the class LinkedStack that you generate, this program must compile and generate the following output:

#### Output

```text
 d? d
 d? d
 c? c
 isEmpty 0? 0
 c b a? c b a
 isEmpty 1? 1
```

LinkedStack must use a singly linked structure. It is recommended you keep a pointer to the top of the stack and push new elements onto the front. If top == nullptr, you can have top refer to a new node with the element. When the stack is not empty, you can add to the first so top references the most recently added. In this case, if you have pushed "First" then stack.push("Second") you could use code shown here in pictures of memory.

![图12-28](img/12-28.png)

### 12C. LinkedPriorityList

This project asks you to implement a collection class LinkedPriorityList using a singly linked structure to store a sequence of string objects (no templates). This new type will store a collection of elements as a zero-based indexed list where the element at index 0 is considered to have higher priority than the element at index 1. Th e element at index size()-1 has the lowest priority. An instance of this collection class will be able to store just one type of element such as <string>.

#### Output

```text
Sleep
Get groceries
Study for the CS exam
```

Complete these methods in LinkedPriorityList so it uses a singly linked structure to store elements. Don’t forget to add struct node in the same file as this class.

```C++
// Construct an empty LinkedPriorityList
LinkedPriorityList();

// Return the number of elements currently in this LinkedPriorityList
int size();

// Return true if size() == 0 or false if size() > 0
bool isEmpty();

// Insert the element at the given index.
// precondition: index is on the range of 0 through size() void
insertElementAt(int index, std::string el);

// Return a reference to the element at the given index.
// precondition: index is on the range of 0 through size()-1
 std::string getElementAt(int index);

// Remove the element at the given index.
// precondition: index is on the range of 0 through size()-1
void removeElementAt(int index);

// Swap the element located at index with the element at index+1.
// Lower the priority of the element at index size()-1 has no effect.
// precondition: index is on the range of 0 through size() 
void lowerPriorityOf(int index);

// Swap the element located at index with the element at index-1.
// An attempt to raise the priority at index 0 has no effect.
// precondition: index is on the range of 0 through size() 
void raisePriorityOf(int index);

// Move the element at the given index to the end of this list.
// An attempt to move the last element to the last has no effect.
// precondition: index is on the range of 0 through size()-1
void moveToLast(int index);

// Move the element at the given index to the front of this list.
// An attempt to move the top element to the top has no effect.
// precondition: index is on the range of 0 through size()-1
void moveToTop(int index);
```

To help you understand how these methods work, consider the program below that shows the changing list as each of the messages is sent to list. Recommended: implement one member function at a time, and write tests to ensure that it works.

```C++
#include <iostream>
#include "LinkedPriorityList.h"
using namespace std;

int main() {
    LinkedPriorityList list;
    list.insertElementAt(0, "a");
    list.insertElementAt(1, "b");
    list.insertElementAt(2, "c");
    list.insertElementAt(3, "d");
    for (int i = 0; i < list.size(); i++) // a b c d
        cout << list.getElementAt(i) << " ";
    cout << endl;

    list.insertElementAt(1, "f");
    for (int i = 0; i < list.size(); i++) // a f b c d
        cout << list.getElementAt(i) << " ";
    cout << endl;

    list.removeElementAt(0);
    for (int i = 0; i < list.size(); i++) // f b c d
        cout << list.getElementAt(i) << " ";
    cout << endl;

    list.lowerPriorityOf(3); // no effect
    list.lowerPriorityOf(0); // move f right
    list.lowerPriorityOf(1); // move f right
    list.lowerPriorityOf(2); // move f right
    for (int i = 0; i < list.size(); i++) // b c d f
        cout << list.getElementAt(i) << " ";
    cout << endl;

    list.raisePriorityOf(0); // no effect
    list.raisePriorityOf(2); // move d left
    list.raisePriorityOf(1); // move d left
    for (int i = 0; i < list.size(); i++) // d b c f
        cout << list.getElementAt(i) << " ";
    cout << endl;

    list.moveToLast(list.size() - 1); // no effect
    list.moveToLast(0); // move d from top priority to last priority
    for (int i = 0; i < list.size(); i++) // b c f d
        cout << list.getElementAt(i) << " ";
    cout << endl;

    list.moveToTop(0); // no effect
    list.moveToTop(2); // move f to top priority again
    for (int i = 0; i < list.size(); i++) // f b c d
        cout << list.getElementAt(i) << " ";

    return 0;
}
```

### 12D. LinkedPriorityList<Type> THROWS EXCEPTIONS

Change your code so it throws an exception when the index is out of range. To do this, first add this #include to PriorityList<Type>:

```C++
#include <stdexcept>
```

Then add an if statement to every method that takes index as a parameter. An exception will be thrown if the programmer supplies an incorrect index like -1 or an index > size(), which is a good thing:

```C++
// Insert the element at the given index.
// precondition: index is on the range of 0 through size()
void insertElementAt(int index, Type element) {
    if (index < 0 || index > size()) {
        throw std::invalid_argument(
            "\ninsertElementAt: index must be 0..size()");
    } // . . .
```
